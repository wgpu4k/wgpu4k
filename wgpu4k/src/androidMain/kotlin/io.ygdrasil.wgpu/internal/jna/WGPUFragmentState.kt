// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.AddressLayout
import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUFragmentState {
 * *     const WGPUChainedStruct *nextInChain;
 * *     WGPUShaderModule module;
 * *     const char *entryPoint;
 * *     size_t constantCount;
 * *     const WGPUConstantEntry *constants;
 * *     size_t targetCount;
 * *     const WGPUColorTargetState *targets;
 * * }
 * * }
 */
object WGPUFragmentState {
    private val `$LAYOUT` = structLayout(
        wgpu_h.C_POINTER.withName("nextInChain"),
        wgpu_h.C_POINTER.withName("module"),
        wgpu_h.C_POINTER.withName("entryPoint"),
        wgpu_h.C_LONG.withName("constantCount"),
        wgpu_h.C_POINTER.withName("constants"),
        wgpu_h.C_LONG.withName("targetCount"),
        wgpu_h.C_POINTER.withName("targets")
    ).withName("WGPUFragmentState")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `nextInChain$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("nextInChain")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$layout`(): AddressLayout {
        return `nextInChain$LAYOUT`
    }

    private const val `nextInChain$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$offset`(): Long {
        return `nextInChain$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment): MemorySegment {
        return struct.get(`nextInChain$LAYOUT`, `nextInChain$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `nextInChain$LAYOUT`, `nextInChain$OFFSET`,
            fieldValue!!
        )
    }

    private val `module$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("module")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUShaderModule module
     * * }
     */
    fun `module$layout`(): AddressLayout {
        return `module$LAYOUT`
    }

    private const val `module$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUShaderModule module
     * * }
     */
    fun `module$offset`(): Long {
        return `module$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUShaderModule module
     * * }
     */
    fun module(struct: MemorySegment): MemorySegment {
        return struct.get(`module$LAYOUT`, `module$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUShaderModule module
     * * }
     */
    fun module(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `module$LAYOUT`, `module$OFFSET`,
            fieldValue!!
        )
    }

    private val `entryPoint$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("entryPoint")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const char *entryPoint
     * * }
     */
    fun `entryPoint$layout`(): AddressLayout {
        return `entryPoint$LAYOUT`
    }

    private const val `entryPoint$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const char *entryPoint
     * * }
     */
    fun `entryPoint$offset`(): Long {
        return `entryPoint$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const char *entryPoint
     * * }
     */
    fun entryPoint(struct: MemorySegment): MemorySegment {
        return struct.get(`entryPoint$LAYOUT`, `entryPoint$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const char *entryPoint
     * * }
     */
    fun entryPoint(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `entryPoint$LAYOUT`, `entryPoint$OFFSET`,
            fieldValue!!
        )
    }

    private val `constantCount$LAYOUT` = `$LAYOUT`.select(groupElement("constantCount")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * size_t constantCount
     * * }
     */
    fun `constantCount$layout`(): ValueLayout.OfLong {
        return `constantCount$LAYOUT`
    }

    private const val `constantCount$OFFSET`: Long = 24

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * size_t constantCount
     * * }
     */
    fun `constantCount$offset`(): Long {
        return `constantCount$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * size_t constantCount
     * * }
     */
    fun constantCount(struct: MemorySegment): Long {
        return struct.get(`constantCount$LAYOUT`, `constantCount$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * size_t constantCount
     * * }
     */
    fun constantCount(struct: MemorySegment, fieldValue: Long) {
        struct.set(`constantCount$LAYOUT`, `constantCount$OFFSET`, fieldValue)
    }

    private val `constants$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("constants")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUConstantEntry *constants
     * * }
     */
    fun `constants$layout`(): AddressLayout {
        return `constants$LAYOUT`
    }

    private const val `constants$OFFSET`: Long = 32

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUConstantEntry *constants
     * * }
     */
    fun `constants$offset`(): Long {
        return `constants$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUConstantEntry *constants
     * * }
     */
    fun constants(struct: MemorySegment): MemorySegment {
        return struct.get(`constants$LAYOUT`, `constants$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUConstantEntry *constants
     * * }
     */
    fun constants(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `constants$LAYOUT`, `constants$OFFSET`,
            fieldValue!!
        )
    }

    private val `targetCount$LAYOUT` = `$LAYOUT`.select(groupElement("targetCount")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * size_t targetCount
     * * }
     */
    fun `targetCount$layout`(): ValueLayout.OfLong {
        return `targetCount$LAYOUT`
    }

    private const val `targetCount$OFFSET`: Long = 40

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * size_t targetCount
     * * }
     */
    fun `targetCount$offset`(): Long {
        return `targetCount$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * size_t targetCount
     * * }
     */
    fun targetCount(struct: MemorySegment): Long {
        return struct.get(`targetCount$LAYOUT`, `targetCount$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * size_t targetCount
     * * }
     */
    fun targetCount(struct: MemorySegment, fieldValue: Long) {
        struct.set(`targetCount$LAYOUT`, `targetCount$OFFSET`, fieldValue)
    }

    private val `targets$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("targets")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUColorTargetState *targets
     * * }
     */
    fun `targets$layout`(): AddressLayout {
        return `targets$LAYOUT`
    }

    private const val `targets$OFFSET`: Long = 48

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUColorTargetState *targets
     * * }
     */
    fun `targets$offset`(): Long {
        return `targets$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUColorTargetState *targets
     * * }
     */
    fun targets(struct: MemorySegment): MemorySegment {
        return struct.get(`targets$LAYOUT`, `targets$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUColorTargetState *targets
     * * }
     */
    fun targets(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `targets$LAYOUT`, `targets$OFFSET`,
            fieldValue!!
        )
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

