// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.AddressLayout
import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUBindGroupLayoutEntry {
 * *     const WGPUChainedStruct *nextInChain;
 * *     uint32_t binding;
 * *     WGPUShaderStageFlags visibility;
 * *     WGPUBufferBindingLayout buffer;
 * *     WGPUSamplerBindingLayout sampler;
 * *     WGPUTextureBindingLayout texture;
 * *     WGPUStorageTextureBindingLayout storageTexture;
 * * }
 * * }
 */
object WGPUBindGroupLayoutEntry {
    private val `$LAYOUT` = structLayout(
        wgpu_h.C_POINTER.withName("nextInChain"),
        wgpu_h.C_INT.withName("binding"),
        wgpu_h.C_INT.withName("visibility"),
        WGPUBufferBindingLayout.layout().withName("buffer"),
        WGPUSamplerBindingLayout.layout().withName("sampler"),
        WGPUTextureBindingLayout.layout().withName("texture"),
        WGPUStorageTextureBindingLayout.layout().withName("storageTexture")
    ).withName("WGPUBindGroupLayoutEntry")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `nextInChain$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("nextInChain")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$layout`(): AddressLayout {
        return `nextInChain$LAYOUT`
    }

    private const val `nextInChain$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$offset`(): Long {
        return `nextInChain$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment): MemorySegment {
        return struct.get(`nextInChain$LAYOUT`, `nextInChain$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `nextInChain$LAYOUT`, `nextInChain$OFFSET`,
            fieldValue!!
        )
    }

    private val `binding$LAYOUT` = `$LAYOUT`.select(groupElement("binding")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t binding
     * * }
     */
    fun `binding$layout`(): ValueLayout.OfInt {
        return `binding$LAYOUT`
    }

    private const val `binding$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t binding
     * * }
     */
    fun `binding$offset`(): Long {
        return `binding$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t binding
     * * }
     */
    fun binding(struct: MemorySegment): Int {
        return struct.get(`binding$LAYOUT`, `binding$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t binding
     * * }
     */
    fun binding(struct: MemorySegment, fieldValue: Int) {
        struct.set(`binding$LAYOUT`, `binding$OFFSET`, fieldValue)
    }

    private val `visibility$LAYOUT` = `$LAYOUT`.select(groupElement("visibility")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUShaderStageFlags visibility
     * * }
     */
    fun `visibility$layout`(): ValueLayout.OfInt {
        return `visibility$LAYOUT`
    }

    private const val `visibility$OFFSET`: Long = 12

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUShaderStageFlags visibility
     * * }
     */
    fun `visibility$offset`(): Long {
        return `visibility$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUShaderStageFlags visibility
     * * }
     */
    fun visibility(struct: MemorySegment): Int {
        return struct.get(`visibility$LAYOUT`, `visibility$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUShaderStageFlags visibility
     * * }
     */
    fun visibility(struct: MemorySegment, fieldValue: Int) {
        struct.set(`visibility$LAYOUT`, `visibility$OFFSET`, fieldValue)
    }

    private val `buffer$LAYOUT` = `$LAYOUT`.select(groupElement("buffer")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUBufferBindingLayout buffer
     * * }
     */
    fun `buffer$layout`(): GroupLayout {
        return `buffer$LAYOUT`
    }

    private const val `buffer$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUBufferBindingLayout buffer
     * * }
     */
    fun `buffer$offset`(): Long {
        return `buffer$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUBufferBindingLayout buffer
     * * }
     */
    fun buffer(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`buffer$OFFSET`, `buffer$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUBufferBindingLayout buffer
     * * }
     */
    fun buffer(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `buffer$OFFSET`, `buffer$LAYOUT`.byteSize()
        )
    }

    private val `sampler$LAYOUT` = `$LAYOUT`.select(groupElement("sampler")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUSamplerBindingLayout sampler
     * * }
     */
    fun `sampler$layout`(): GroupLayout {
        return `sampler$LAYOUT`
    }

    private const val `sampler$OFFSET`: Long = 40

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUSamplerBindingLayout sampler
     * * }
     */
    fun `sampler$offset`(): Long {
        return `sampler$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUSamplerBindingLayout sampler
     * * }
     */
    fun sampler(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`sampler$OFFSET`, `sampler$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUSamplerBindingLayout sampler
     * * }
     */
    fun sampler(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `sampler$OFFSET`, `sampler$LAYOUT`.byteSize()
        )
    }

    private val `texture$LAYOUT` = `$LAYOUT`.select(groupElement("texture")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUTextureBindingLayout texture
     * * }
     */
    fun `texture$layout`(): GroupLayout {
        return `texture$LAYOUT`
    }

    private const val `texture$OFFSET`: Long = 56

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUTextureBindingLayout texture
     * * }
     */
    fun `texture$offset`(): Long {
        return `texture$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUTextureBindingLayout texture
     * * }
     */
    fun texture(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`texture$OFFSET`, `texture$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUTextureBindingLayout texture
     * * }
     */
    fun texture(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `texture$OFFSET`, `texture$LAYOUT`.byteSize()
        )
    }

    private val `storageTexture$LAYOUT` = `$LAYOUT`.select(groupElement("storageTexture")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStorageTextureBindingLayout storageTexture
     * * }
     */
    fun `storageTexture$layout`(): GroupLayout {
        return `storageTexture$LAYOUT`
    }

    private const val `storageTexture$OFFSET`: Long = 80

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStorageTextureBindingLayout storageTexture
     * * }
     */
    fun `storageTexture$offset`(): Long {
        return `storageTexture$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStorageTextureBindingLayout storageTexture
     * * }
     */
    fun storageTexture(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`storageTexture$OFFSET`, `storageTexture$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStorageTextureBindingLayout storageTexture
     * * }
     */
    fun storageTexture(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `storageTexture$OFFSET`, `storageTexture$LAYOUT`.byteSize()
        )
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

