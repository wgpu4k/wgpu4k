// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.paddingLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPULimits {
 * *     uint32_t maxTextureDimension1D;
 * *     uint32_t maxTextureDimension2D;
 * *     uint32_t maxTextureDimension3D;
 * *     uint32_t maxTextureArrayLayers;
 * *     uint32_t maxBindGroups;
 * *     uint32_t maxBindGroupsPlusVertexBuffers;
 * *     uint32_t maxBindingsPerBindGroup;
 * *     uint32_t maxDynamicUniformBuffersPerPipelineLayout;
 * *     uint32_t maxDynamicStorageBuffersPerPipelineLayout;
 * *     uint32_t maxSampledTexturesPerShaderStage;
 * *     uint32_t maxSamplersPerShaderStage;
 * *     uint32_t maxStorageBuffersPerShaderStage;
 * *     uint32_t maxStorageTexturesPerShaderStage;
 * *     uint32_t maxUniformBuffersPerShaderStage;
 * *     uint64_t maxUniformBufferBindingSize;
 * *     uint64_t maxStorageBufferBindingSize;
 * *     uint32_t minUniformBufferOffsetAlignment;
 * *     uint32_t minStorageBufferOffsetAlignment;
 * *     uint32_t maxVertexBuffers;
 * *     uint64_t maxBufferSize;
 * *     uint32_t maxVertexAttributes;
 * *     uint32_t maxVertexBufferArrayStride;
 * *     uint32_t maxInterStageShaderComponents;
 * *     uint32_t maxInterStageShaderVariables;
 * *     uint32_t maxColorAttachments;
 * *     uint32_t maxColorAttachmentBytesPerSample;
 * *     uint32_t maxComputeWorkgroupStorageSize;
 * *     uint32_t maxComputeInvocationsPerWorkgroup;
 * *     uint32_t maxComputeWorkgroupSizeX;
 * *     uint32_t maxComputeWorkgroupSizeY;
 * *     uint32_t maxComputeWorkgroupSizeZ;
 * *     uint32_t maxComputeWorkgroupsPerDimension;
 * * }
 * * }
 */
object WGPULimits {
    private val `$LAYOUT` = structLayout(
        wgpu_h.C_INT.withName("maxTextureDimension1D"),
        wgpu_h.C_INT.withName("maxTextureDimension2D"),
        wgpu_h.C_INT.withName("maxTextureDimension3D"),
        wgpu_h.C_INT.withName("maxTextureArrayLayers"),
        wgpu_h.C_INT.withName("maxBindGroups"),
        wgpu_h.C_INT.withName("maxBindGroupsPlusVertexBuffers"),
        wgpu_h.C_INT.withName("maxBindingsPerBindGroup"),
        wgpu_h.C_INT.withName("maxDynamicUniformBuffersPerPipelineLayout"),
        wgpu_h.C_INT.withName("maxDynamicStorageBuffersPerPipelineLayout"),
        wgpu_h.C_INT.withName("maxSampledTexturesPerShaderStage"),
        wgpu_h.C_INT.withName("maxSamplersPerShaderStage"),
        wgpu_h.C_INT.withName("maxStorageBuffersPerShaderStage"),
        wgpu_h.C_INT.withName("maxStorageTexturesPerShaderStage"),
        wgpu_h.C_INT.withName("maxUniformBuffersPerShaderStage"),
        wgpu_h.C_LONG_LONG.withName("maxUniformBufferBindingSize"),
        wgpu_h.C_LONG_LONG.withName("maxStorageBufferBindingSize"),
        wgpu_h.C_INT.withName("minUniformBufferOffsetAlignment"),
        wgpu_h.C_INT.withName("minStorageBufferOffsetAlignment"),
        wgpu_h.C_INT.withName("maxVertexBuffers"),
        paddingLayout(4),
        wgpu_h.C_LONG_LONG.withName("maxBufferSize"),
        wgpu_h.C_INT.withName("maxVertexAttributes"),
        wgpu_h.C_INT.withName("maxVertexBufferArrayStride"),
        wgpu_h.C_INT.withName("maxInterStageShaderComponents"),
        wgpu_h.C_INT.withName("maxInterStageShaderVariables"),
        wgpu_h.C_INT.withName("maxColorAttachments"),
        wgpu_h.C_INT.withName("maxColorAttachmentBytesPerSample"),
        wgpu_h.C_INT.withName("maxComputeWorkgroupStorageSize"),
        wgpu_h.C_INT.withName("maxComputeInvocationsPerWorkgroup"),
        wgpu_h.C_INT.withName("maxComputeWorkgroupSizeX"),
        wgpu_h.C_INT.withName("maxComputeWorkgroupSizeY"),
        wgpu_h.C_INT.withName("maxComputeWorkgroupSizeZ"),
        wgpu_h.C_INT.withName("maxComputeWorkgroupsPerDimension")
    ).withName("WGPULimits")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `maxTextureDimension1D$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxTextureDimension1D")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension1D
     * * }
     */
    fun `maxTextureDimension1D$layout`(): ValueLayout.OfInt {
        return `maxTextureDimension1D$LAYOUT`
    }

    private const val `maxTextureDimension1D$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension1D
     * * }
     */
    fun `maxTextureDimension1D$offset`(): Long {
        return `maxTextureDimension1D$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension1D
     * * }
     */
    fun maxTextureDimension1D(struct: MemorySegment): Int {
        return struct.get(`maxTextureDimension1D$LAYOUT`, `maxTextureDimension1D$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension1D
     * * }
     */
    fun maxTextureDimension1D(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxTextureDimension1D$LAYOUT`, `maxTextureDimension1D$OFFSET`, fieldValue)
    }

    private val `maxTextureDimension2D$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxTextureDimension2D")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension2D
     * * }
     */
    fun `maxTextureDimension2D$layout`(): ValueLayout.OfInt {
        return `maxTextureDimension2D$LAYOUT`
    }

    private const val `maxTextureDimension2D$OFFSET`: Long = 4

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension2D
     * * }
     */
    fun `maxTextureDimension2D$offset`(): Long {
        return `maxTextureDimension2D$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension2D
     * * }
     */
    fun maxTextureDimension2D(struct: MemorySegment): Int {
        return struct.get(`maxTextureDimension2D$LAYOUT`, `maxTextureDimension2D$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension2D
     * * }
     */
    fun maxTextureDimension2D(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxTextureDimension2D$LAYOUT`, `maxTextureDimension2D$OFFSET`, fieldValue)
    }

    private val `maxTextureDimension3D$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxTextureDimension3D")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension3D
     * * }
     */
    fun `maxTextureDimension3D$layout`(): ValueLayout.OfInt {
        return `maxTextureDimension3D$LAYOUT`
    }

    private const val `maxTextureDimension3D$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension3D
     * * }
     */
    fun `maxTextureDimension3D$offset`(): Long {
        return `maxTextureDimension3D$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension3D
     * * }
     */
    fun maxTextureDimension3D(struct: MemorySegment): Int {
        return struct.get(`maxTextureDimension3D$LAYOUT`, `maxTextureDimension3D$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureDimension3D
     * * }
     */
    fun maxTextureDimension3D(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxTextureDimension3D$LAYOUT`, `maxTextureDimension3D$OFFSET`, fieldValue)
    }

    private val `maxTextureArrayLayers$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxTextureArrayLayers")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureArrayLayers
     * * }
     */
    fun `maxTextureArrayLayers$layout`(): ValueLayout.OfInt {
        return `maxTextureArrayLayers$LAYOUT`
    }

    private const val `maxTextureArrayLayers$OFFSET`: Long = 12

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureArrayLayers
     * * }
     */
    fun `maxTextureArrayLayers$offset`(): Long {
        return `maxTextureArrayLayers$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureArrayLayers
     * * }
     */
    fun maxTextureArrayLayers(struct: MemorySegment): Int {
        return struct.get(`maxTextureArrayLayers$LAYOUT`, `maxTextureArrayLayers$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxTextureArrayLayers
     * * }
     */
    fun maxTextureArrayLayers(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxTextureArrayLayers$LAYOUT`, `maxTextureArrayLayers$OFFSET`, fieldValue)
    }

    private val `maxBindGroups$LAYOUT` = `$LAYOUT`.select(groupElement("maxBindGroups")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroups
     * * }
     */
    fun `maxBindGroups$layout`(): ValueLayout.OfInt {
        return `maxBindGroups$LAYOUT`
    }

    private const val `maxBindGroups$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroups
     * * }
     */
    fun `maxBindGroups$offset`(): Long {
        return `maxBindGroups$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroups
     * * }
     */
    fun maxBindGroups(struct: MemorySegment): Int {
        return struct.get(`maxBindGroups$LAYOUT`, `maxBindGroups$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroups
     * * }
     */
    fun maxBindGroups(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxBindGroups$LAYOUT`, `maxBindGroups$OFFSET`, fieldValue)
    }

    private val `maxBindGroupsPlusVertexBuffers$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxBindGroupsPlusVertexBuffers")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroupsPlusVertexBuffers
     * * }
     */
    fun `maxBindGroupsPlusVertexBuffers$layout`(): ValueLayout.OfInt {
        return `maxBindGroupsPlusVertexBuffers$LAYOUT`
    }

    private const val `maxBindGroupsPlusVertexBuffers$OFFSET`: Long = 20

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroupsPlusVertexBuffers
     * * }
     */
    fun `maxBindGroupsPlusVertexBuffers$offset`(): Long {
        return `maxBindGroupsPlusVertexBuffers$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroupsPlusVertexBuffers
     * * }
     */
    fun maxBindGroupsPlusVertexBuffers(struct: MemorySegment): Int {
        return struct.get(`maxBindGroupsPlusVertexBuffers$LAYOUT`, `maxBindGroupsPlusVertexBuffers$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxBindGroupsPlusVertexBuffers
     * * }
     */
    fun maxBindGroupsPlusVertexBuffers(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxBindGroupsPlusVertexBuffers$LAYOUT`, `maxBindGroupsPlusVertexBuffers$OFFSET`, fieldValue)
    }

    private val `maxBindingsPerBindGroup$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxBindingsPerBindGroup")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxBindingsPerBindGroup
     * * }
     */
    fun `maxBindingsPerBindGroup$layout`(): ValueLayout.OfInt {
        return `maxBindingsPerBindGroup$LAYOUT`
    }

    private const val `maxBindingsPerBindGroup$OFFSET`: Long = 24

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxBindingsPerBindGroup
     * * }
     */
    fun `maxBindingsPerBindGroup$offset`(): Long {
        return `maxBindingsPerBindGroup$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxBindingsPerBindGroup
     * * }
     */
    fun maxBindingsPerBindGroup(struct: MemorySegment): Int {
        return struct.get(`maxBindingsPerBindGroup$LAYOUT`, `maxBindingsPerBindGroup$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxBindingsPerBindGroup
     * * }
     */
    fun maxBindingsPerBindGroup(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxBindingsPerBindGroup$LAYOUT`, `maxBindingsPerBindGroup$OFFSET`, fieldValue)
    }

    private val `maxDynamicUniformBuffersPerPipelineLayout$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxDynamicUniformBuffersPerPipelineLayout")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicUniformBuffersPerPipelineLayout
     * * }
     */
    fun `maxDynamicUniformBuffersPerPipelineLayout$layout`(): ValueLayout.OfInt {
        return `maxDynamicUniformBuffersPerPipelineLayout$LAYOUT`
    }

    private const val `maxDynamicUniformBuffersPerPipelineLayout$OFFSET`: Long = 28

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicUniformBuffersPerPipelineLayout
     * * }
     */
    fun `maxDynamicUniformBuffersPerPipelineLayout$offset`(): Long {
        return `maxDynamicUniformBuffersPerPipelineLayout$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicUniformBuffersPerPipelineLayout
     * * }
     */
    fun maxDynamicUniformBuffersPerPipelineLayout(struct: MemorySegment): Int {
        return struct.get(
            `maxDynamicUniformBuffersPerPipelineLayout$LAYOUT`,
            `maxDynamicUniformBuffersPerPipelineLayout$OFFSET`
        )
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicUniformBuffersPerPipelineLayout
     * * }
     */
    fun maxDynamicUniformBuffersPerPipelineLayout(struct: MemorySegment, fieldValue: Int) {
        struct.set(
            `maxDynamicUniformBuffersPerPipelineLayout$LAYOUT`,
            `maxDynamicUniformBuffersPerPipelineLayout$OFFSET`,
            fieldValue
        )
    }

    private val `maxDynamicStorageBuffersPerPipelineLayout$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxDynamicStorageBuffersPerPipelineLayout")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicStorageBuffersPerPipelineLayout
     * * }
     */
    fun `maxDynamicStorageBuffersPerPipelineLayout$layout`(): ValueLayout.OfInt {
        return `maxDynamicStorageBuffersPerPipelineLayout$LAYOUT`
    }

    private const val `maxDynamicStorageBuffersPerPipelineLayout$OFFSET`: Long = 32

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicStorageBuffersPerPipelineLayout
     * * }
     */
    fun `maxDynamicStorageBuffersPerPipelineLayout$offset`(): Long {
        return `maxDynamicStorageBuffersPerPipelineLayout$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicStorageBuffersPerPipelineLayout
     * * }
     */
    fun maxDynamicStorageBuffersPerPipelineLayout(struct: MemorySegment): Int {
        return struct.get(
            `maxDynamicStorageBuffersPerPipelineLayout$LAYOUT`,
            `maxDynamicStorageBuffersPerPipelineLayout$OFFSET`
        )
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxDynamicStorageBuffersPerPipelineLayout
     * * }
     */
    fun maxDynamicStorageBuffersPerPipelineLayout(struct: MemorySegment, fieldValue: Int) {
        struct.set(
            `maxDynamicStorageBuffersPerPipelineLayout$LAYOUT`,
            `maxDynamicStorageBuffersPerPipelineLayout$OFFSET`,
            fieldValue
        )
    }

    private val `maxSampledTexturesPerShaderStage$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxSampledTexturesPerShaderStage")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxSampledTexturesPerShaderStage
     * * }
     */
    fun `maxSampledTexturesPerShaderStage$layout`(): ValueLayout.OfInt {
        return `maxSampledTexturesPerShaderStage$LAYOUT`
    }

    private const val `maxSampledTexturesPerShaderStage$OFFSET`: Long = 36

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxSampledTexturesPerShaderStage
     * * }
     */
    fun `maxSampledTexturesPerShaderStage$offset`(): Long {
        return `maxSampledTexturesPerShaderStage$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxSampledTexturesPerShaderStage
     * * }
     */
    fun maxSampledTexturesPerShaderStage(struct: MemorySegment): Int {
        return struct.get(`maxSampledTexturesPerShaderStage$LAYOUT`, `maxSampledTexturesPerShaderStage$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxSampledTexturesPerShaderStage
     * * }
     */
    fun maxSampledTexturesPerShaderStage(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxSampledTexturesPerShaderStage$LAYOUT`, `maxSampledTexturesPerShaderStage$OFFSET`, fieldValue)
    }

    private val `maxSamplersPerShaderStage$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxSamplersPerShaderStage")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxSamplersPerShaderStage
     * * }
     */
    fun `maxSamplersPerShaderStage$layout`(): ValueLayout.OfInt {
        return `maxSamplersPerShaderStage$LAYOUT`
    }

    private const val `maxSamplersPerShaderStage$OFFSET`: Long = 40

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxSamplersPerShaderStage
     * * }
     */
    fun `maxSamplersPerShaderStage$offset`(): Long {
        return `maxSamplersPerShaderStage$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxSamplersPerShaderStage
     * * }
     */
    fun maxSamplersPerShaderStage(struct: MemorySegment): Int {
        return struct.get(`maxSamplersPerShaderStage$LAYOUT`, `maxSamplersPerShaderStage$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxSamplersPerShaderStage
     * * }
     */
    fun maxSamplersPerShaderStage(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxSamplersPerShaderStage$LAYOUT`, `maxSamplersPerShaderStage$OFFSET`, fieldValue)
    }

    private val `maxStorageBuffersPerShaderStage$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxStorageBuffersPerShaderStage")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageBuffersPerShaderStage
     * * }
     */
    fun `maxStorageBuffersPerShaderStage$layout`(): ValueLayout.OfInt {
        return `maxStorageBuffersPerShaderStage$LAYOUT`
    }

    private const val `maxStorageBuffersPerShaderStage$OFFSET`: Long = 44

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageBuffersPerShaderStage
     * * }
     */
    fun `maxStorageBuffersPerShaderStage$offset`(): Long {
        return `maxStorageBuffersPerShaderStage$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageBuffersPerShaderStage
     * * }
     */
    fun maxStorageBuffersPerShaderStage(struct: MemorySegment): Int {
        return struct.get(`maxStorageBuffersPerShaderStage$LAYOUT`, `maxStorageBuffersPerShaderStage$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageBuffersPerShaderStage
     * * }
     */
    fun maxStorageBuffersPerShaderStage(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxStorageBuffersPerShaderStage$LAYOUT`, `maxStorageBuffersPerShaderStage$OFFSET`, fieldValue)
    }

    private val `maxStorageTexturesPerShaderStage$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxStorageTexturesPerShaderStage")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageTexturesPerShaderStage
     * * }
     */
    fun `maxStorageTexturesPerShaderStage$layout`(): ValueLayout.OfInt {
        return `maxStorageTexturesPerShaderStage$LAYOUT`
    }

    private const val `maxStorageTexturesPerShaderStage$OFFSET`: Long = 48

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageTexturesPerShaderStage
     * * }
     */
    fun `maxStorageTexturesPerShaderStage$offset`(): Long {
        return `maxStorageTexturesPerShaderStage$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageTexturesPerShaderStage
     * * }
     */
    fun maxStorageTexturesPerShaderStage(struct: MemorySegment): Int {
        return struct.get(`maxStorageTexturesPerShaderStage$LAYOUT`, `maxStorageTexturesPerShaderStage$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxStorageTexturesPerShaderStage
     * * }
     */
    fun maxStorageTexturesPerShaderStage(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxStorageTexturesPerShaderStage$LAYOUT`, `maxStorageTexturesPerShaderStage$OFFSET`, fieldValue)
    }

    private val `maxUniformBuffersPerShaderStage$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxUniformBuffersPerShaderStage")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxUniformBuffersPerShaderStage
     * * }
     */
    fun `maxUniformBuffersPerShaderStage$layout`(): ValueLayout.OfInt {
        return `maxUniformBuffersPerShaderStage$LAYOUT`
    }

    private const val `maxUniformBuffersPerShaderStage$OFFSET`: Long = 52

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxUniformBuffersPerShaderStage
     * * }
     */
    fun `maxUniformBuffersPerShaderStage$offset`(): Long {
        return `maxUniformBuffersPerShaderStage$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxUniformBuffersPerShaderStage
     * * }
     */
    fun maxUniformBuffersPerShaderStage(struct: MemorySegment): Int {
        return struct.get(`maxUniformBuffersPerShaderStage$LAYOUT`, `maxUniformBuffersPerShaderStage$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxUniformBuffersPerShaderStage
     * * }
     */
    fun maxUniformBuffersPerShaderStage(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxUniformBuffersPerShaderStage$LAYOUT`, `maxUniformBuffersPerShaderStage$OFFSET`, fieldValue)
    }

    private val `maxUniformBufferBindingSize$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxUniformBufferBindingSize")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint64_t maxUniformBufferBindingSize
     * * }
     */
    fun `maxUniformBufferBindingSize$layout`(): ValueLayout.OfLong {
        return `maxUniformBufferBindingSize$LAYOUT`
    }

    private const val `maxUniformBufferBindingSize$OFFSET`: Long = 56

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint64_t maxUniformBufferBindingSize
     * * }
     */
    fun `maxUniformBufferBindingSize$offset`(): Long {
        return `maxUniformBufferBindingSize$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint64_t maxUniformBufferBindingSize
     * * }
     */
    fun maxUniformBufferBindingSize(struct: MemorySegment): Long {
        return struct.get(`maxUniformBufferBindingSize$LAYOUT`, `maxUniformBufferBindingSize$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint64_t maxUniformBufferBindingSize
     * * }
     */
    fun maxUniformBufferBindingSize(struct: MemorySegment, fieldValue: Long) {
        struct.set(`maxUniformBufferBindingSize$LAYOUT`, `maxUniformBufferBindingSize$OFFSET`, fieldValue)
    }

    private val `maxStorageBufferBindingSize$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxStorageBufferBindingSize")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint64_t maxStorageBufferBindingSize
     * * }
     */
    fun `maxStorageBufferBindingSize$layout`(): ValueLayout.OfLong {
        return `maxStorageBufferBindingSize$LAYOUT`
    }

    private const val `maxStorageBufferBindingSize$OFFSET`: Long = 64

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint64_t maxStorageBufferBindingSize
     * * }
     */
    fun `maxStorageBufferBindingSize$offset`(): Long {
        return `maxStorageBufferBindingSize$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint64_t maxStorageBufferBindingSize
     * * }
     */
    fun maxStorageBufferBindingSize(struct: MemorySegment): Long {
        return struct.get(`maxStorageBufferBindingSize$LAYOUT`, `maxStorageBufferBindingSize$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint64_t maxStorageBufferBindingSize
     * * }
     */
    fun maxStorageBufferBindingSize(struct: MemorySegment, fieldValue: Long) {
        struct.set(`maxStorageBufferBindingSize$LAYOUT`, `maxStorageBufferBindingSize$OFFSET`, fieldValue)
    }

    private val `minUniformBufferOffsetAlignment$LAYOUT` =
        `$LAYOUT`.select(groupElement("minUniformBufferOffsetAlignment")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t minUniformBufferOffsetAlignment
     * * }
     */
    fun `minUniformBufferOffsetAlignment$layout`(): ValueLayout.OfInt {
        return `minUniformBufferOffsetAlignment$LAYOUT`
    }

    private const val `minUniformBufferOffsetAlignment$OFFSET`: Long = 72

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t minUniformBufferOffsetAlignment
     * * }
     */
    fun `minUniformBufferOffsetAlignment$offset`(): Long {
        return `minUniformBufferOffsetAlignment$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t minUniformBufferOffsetAlignment
     * * }
     */
    fun minUniformBufferOffsetAlignment(struct: MemorySegment): Int {
        return struct.get(`minUniformBufferOffsetAlignment$LAYOUT`, `minUniformBufferOffsetAlignment$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t minUniformBufferOffsetAlignment
     * * }
     */
    fun minUniformBufferOffsetAlignment(struct: MemorySegment, fieldValue: Int) {
        struct.set(`minUniformBufferOffsetAlignment$LAYOUT`, `minUniformBufferOffsetAlignment$OFFSET`, fieldValue)
    }

    private val `minStorageBufferOffsetAlignment$LAYOUT` =
        `$LAYOUT`.select(groupElement("minStorageBufferOffsetAlignment")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t minStorageBufferOffsetAlignment
     * * }
     */
    fun `minStorageBufferOffsetAlignment$layout`(): ValueLayout.OfInt {
        return `minStorageBufferOffsetAlignment$LAYOUT`
    }

    private const val `minStorageBufferOffsetAlignment$OFFSET`: Long = 76

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t minStorageBufferOffsetAlignment
     * * }
     */
    fun `minStorageBufferOffsetAlignment$offset`(): Long {
        return `minStorageBufferOffsetAlignment$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t minStorageBufferOffsetAlignment
     * * }
     */
    fun minStorageBufferOffsetAlignment(struct: MemorySegment): Int {
        return struct.get(`minStorageBufferOffsetAlignment$LAYOUT`, `minStorageBufferOffsetAlignment$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t minStorageBufferOffsetAlignment
     * * }
     */
    fun minStorageBufferOffsetAlignment(struct: MemorySegment, fieldValue: Int) {
        struct.set(`minStorageBufferOffsetAlignment$LAYOUT`, `minStorageBufferOffsetAlignment$OFFSET`, fieldValue)
    }

    private val `maxVertexBuffers$LAYOUT` = `$LAYOUT`.select(groupElement("maxVertexBuffers")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBuffers
     * * }
     */
    fun `maxVertexBuffers$layout`(): ValueLayout.OfInt {
        return `maxVertexBuffers$LAYOUT`
    }

    private const val `maxVertexBuffers$OFFSET`: Long = 80

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBuffers
     * * }
     */
    fun `maxVertexBuffers$offset`(): Long {
        return `maxVertexBuffers$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBuffers
     * * }
     */
    fun maxVertexBuffers(struct: MemorySegment): Int {
        return struct.get(`maxVertexBuffers$LAYOUT`, `maxVertexBuffers$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBuffers
     * * }
     */
    fun maxVertexBuffers(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxVertexBuffers$LAYOUT`, `maxVertexBuffers$OFFSET`, fieldValue)
    }

    private val `maxBufferSize$LAYOUT` = `$LAYOUT`.select(groupElement("maxBufferSize")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint64_t maxBufferSize
     * * }
     */
    fun `maxBufferSize$layout`(): ValueLayout.OfLong {
        return `maxBufferSize$LAYOUT`
    }

    private const val `maxBufferSize$OFFSET`: Long = 88

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint64_t maxBufferSize
     * * }
     */
    fun `maxBufferSize$offset`(): Long {
        return `maxBufferSize$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint64_t maxBufferSize
     * * }
     */
    fun maxBufferSize(struct: MemorySegment): Long {
        return struct.get(`maxBufferSize$LAYOUT`, `maxBufferSize$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint64_t maxBufferSize
     * * }
     */
    fun maxBufferSize(struct: MemorySegment, fieldValue: Long) {
        struct.set(`maxBufferSize$LAYOUT`, `maxBufferSize$OFFSET`, fieldValue)
    }

    private val `maxVertexAttributes$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxVertexAttributes")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexAttributes
     * * }
     */
    fun `maxVertexAttributes$layout`(): ValueLayout.OfInt {
        return `maxVertexAttributes$LAYOUT`
    }

    private const val `maxVertexAttributes$OFFSET`: Long = 96

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexAttributes
     * * }
     */
    fun `maxVertexAttributes$offset`(): Long {
        return `maxVertexAttributes$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexAttributes
     * * }
     */
    fun maxVertexAttributes(struct: MemorySegment): Int {
        return struct.get(`maxVertexAttributes$LAYOUT`, `maxVertexAttributes$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexAttributes
     * * }
     */
    fun maxVertexAttributes(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxVertexAttributes$LAYOUT`, `maxVertexAttributes$OFFSET`, fieldValue)
    }

    private val `maxVertexBufferArrayStride$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxVertexBufferArrayStride")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBufferArrayStride
     * * }
     */
    fun `maxVertexBufferArrayStride$layout`(): ValueLayout.OfInt {
        return `maxVertexBufferArrayStride$LAYOUT`
    }

    private const val `maxVertexBufferArrayStride$OFFSET`: Long = 100

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBufferArrayStride
     * * }
     */
    fun `maxVertexBufferArrayStride$offset`(): Long {
        return `maxVertexBufferArrayStride$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBufferArrayStride
     * * }
     */
    fun maxVertexBufferArrayStride(struct: MemorySegment): Int {
        return struct.get(`maxVertexBufferArrayStride$LAYOUT`, `maxVertexBufferArrayStride$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxVertexBufferArrayStride
     * * }
     */
    fun maxVertexBufferArrayStride(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxVertexBufferArrayStride$LAYOUT`, `maxVertexBufferArrayStride$OFFSET`, fieldValue)
    }

    private val `maxInterStageShaderComponents$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxInterStageShaderComponents")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderComponents
     * * }
     */
    fun `maxInterStageShaderComponents$layout`(): ValueLayout.OfInt {
        return `maxInterStageShaderComponents$LAYOUT`
    }

    private const val `maxInterStageShaderComponents$OFFSET`: Long = 104

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderComponents
     * * }
     */
    fun `maxInterStageShaderComponents$offset`(): Long {
        return `maxInterStageShaderComponents$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderComponents
     * * }
     */
    fun maxInterStageShaderComponents(struct: MemorySegment): Int {
        return struct.get(`maxInterStageShaderComponents$LAYOUT`, `maxInterStageShaderComponents$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderComponents
     * * }
     */
    fun maxInterStageShaderComponents(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxInterStageShaderComponents$LAYOUT`, `maxInterStageShaderComponents$OFFSET`, fieldValue)
    }

    private val `maxInterStageShaderVariables$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxInterStageShaderVariables")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderVariables
     * * }
     */
    fun `maxInterStageShaderVariables$layout`(): ValueLayout.OfInt {
        return `maxInterStageShaderVariables$LAYOUT`
    }

    private const val `maxInterStageShaderVariables$OFFSET`: Long = 108

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderVariables
     * * }
     */
    fun `maxInterStageShaderVariables$offset`(): Long {
        return `maxInterStageShaderVariables$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderVariables
     * * }
     */
    fun maxInterStageShaderVariables(struct: MemorySegment): Int {
        return struct.get(`maxInterStageShaderVariables$LAYOUT`, `maxInterStageShaderVariables$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxInterStageShaderVariables
     * * }
     */
    fun maxInterStageShaderVariables(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxInterStageShaderVariables$LAYOUT`, `maxInterStageShaderVariables$OFFSET`, fieldValue)
    }

    private val `maxColorAttachments$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxColorAttachments")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachments
     * * }
     */
    fun `maxColorAttachments$layout`(): ValueLayout.OfInt {
        return `maxColorAttachments$LAYOUT`
    }

    private const val `maxColorAttachments$OFFSET`: Long = 112

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachments
     * * }
     */
    fun `maxColorAttachments$offset`(): Long {
        return `maxColorAttachments$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachments
     * * }
     */
    fun maxColorAttachments(struct: MemorySegment): Int {
        return struct.get(`maxColorAttachments$LAYOUT`, `maxColorAttachments$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachments
     * * }
     */
    fun maxColorAttachments(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxColorAttachments$LAYOUT`, `maxColorAttachments$OFFSET`, fieldValue)
    }

    private val `maxColorAttachmentBytesPerSample$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxColorAttachmentBytesPerSample")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachmentBytesPerSample
     * * }
     */
    fun `maxColorAttachmentBytesPerSample$layout`(): ValueLayout.OfInt {
        return `maxColorAttachmentBytesPerSample$LAYOUT`
    }

    private const val `maxColorAttachmentBytesPerSample$OFFSET`: Long = 116

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachmentBytesPerSample
     * * }
     */
    fun `maxColorAttachmentBytesPerSample$offset`(): Long {
        return `maxColorAttachmentBytesPerSample$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachmentBytesPerSample
     * * }
     */
    fun maxColorAttachmentBytesPerSample(struct: MemorySegment): Int {
        return struct.get(`maxColorAttachmentBytesPerSample$LAYOUT`, `maxColorAttachmentBytesPerSample$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxColorAttachmentBytesPerSample
     * * }
     */
    fun maxColorAttachmentBytesPerSample(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxColorAttachmentBytesPerSample$LAYOUT`, `maxColorAttachmentBytesPerSample$OFFSET`, fieldValue)
    }

    private val `maxComputeWorkgroupStorageSize$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxComputeWorkgroupStorageSize")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupStorageSize
     * * }
     */
    fun `maxComputeWorkgroupStorageSize$layout`(): ValueLayout.OfInt {
        return `maxComputeWorkgroupStorageSize$LAYOUT`
    }

    private const val `maxComputeWorkgroupStorageSize$OFFSET`: Long = 120

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupStorageSize
     * * }
     */
    fun `maxComputeWorkgroupStorageSize$offset`(): Long {
        return `maxComputeWorkgroupStorageSize$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupStorageSize
     * * }
     */
    fun maxComputeWorkgroupStorageSize(struct: MemorySegment): Int {
        return struct.get(`maxComputeWorkgroupStorageSize$LAYOUT`, `maxComputeWorkgroupStorageSize$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupStorageSize
     * * }
     */
    fun maxComputeWorkgroupStorageSize(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxComputeWorkgroupStorageSize$LAYOUT`, `maxComputeWorkgroupStorageSize$OFFSET`, fieldValue)
    }

    private val `maxComputeInvocationsPerWorkgroup$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxComputeInvocationsPerWorkgroup")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeInvocationsPerWorkgroup
     * * }
     */
    fun `maxComputeInvocationsPerWorkgroup$layout`(): ValueLayout.OfInt {
        return `maxComputeInvocationsPerWorkgroup$LAYOUT`
    }

    private const val `maxComputeInvocationsPerWorkgroup$OFFSET`: Long = 124

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeInvocationsPerWorkgroup
     * * }
     */
    fun `maxComputeInvocationsPerWorkgroup$offset`(): Long {
        return `maxComputeInvocationsPerWorkgroup$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeInvocationsPerWorkgroup
     * * }
     */
    fun maxComputeInvocationsPerWorkgroup(struct: MemorySegment): Int {
        return struct.get(`maxComputeInvocationsPerWorkgroup$LAYOUT`, `maxComputeInvocationsPerWorkgroup$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeInvocationsPerWorkgroup
     * * }
     */
    fun maxComputeInvocationsPerWorkgroup(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxComputeInvocationsPerWorkgroup$LAYOUT`, `maxComputeInvocationsPerWorkgroup$OFFSET`, fieldValue)
    }

    private val `maxComputeWorkgroupSizeX$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxComputeWorkgroupSizeX")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeX
     * * }
     */
    fun `maxComputeWorkgroupSizeX$layout`(): ValueLayout.OfInt {
        return `maxComputeWorkgroupSizeX$LAYOUT`
    }

    private const val `maxComputeWorkgroupSizeX$OFFSET`: Long = 128

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeX
     * * }
     */
    fun `maxComputeWorkgroupSizeX$offset`(): Long {
        return `maxComputeWorkgroupSizeX$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeX
     * * }
     */
    fun maxComputeWorkgroupSizeX(struct: MemorySegment): Int {
        return struct.get(`maxComputeWorkgroupSizeX$LAYOUT`, `maxComputeWorkgroupSizeX$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeX
     * * }
     */
    fun maxComputeWorkgroupSizeX(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxComputeWorkgroupSizeX$LAYOUT`, `maxComputeWorkgroupSizeX$OFFSET`, fieldValue)
    }

    private val `maxComputeWorkgroupSizeY$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxComputeWorkgroupSizeY")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeY
     * * }
     */
    fun `maxComputeWorkgroupSizeY$layout`(): ValueLayout.OfInt {
        return `maxComputeWorkgroupSizeY$LAYOUT`
    }

    private const val `maxComputeWorkgroupSizeY$OFFSET`: Long = 132

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeY
     * * }
     */
    fun `maxComputeWorkgroupSizeY$offset`(): Long {
        return `maxComputeWorkgroupSizeY$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeY
     * * }
     */
    fun maxComputeWorkgroupSizeY(struct: MemorySegment): Int {
        return struct.get(`maxComputeWorkgroupSizeY$LAYOUT`, `maxComputeWorkgroupSizeY$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeY
     * * }
     */
    fun maxComputeWorkgroupSizeY(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxComputeWorkgroupSizeY$LAYOUT`, `maxComputeWorkgroupSizeY$OFFSET`, fieldValue)
    }

    private val `maxComputeWorkgroupSizeZ$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxComputeWorkgroupSizeZ")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeZ
     * * }
     */
    fun `maxComputeWorkgroupSizeZ$layout`(): ValueLayout.OfInt {
        return `maxComputeWorkgroupSizeZ$LAYOUT`
    }

    private const val `maxComputeWorkgroupSizeZ$OFFSET`: Long = 136

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeZ
     * * }
     */
    fun `maxComputeWorkgroupSizeZ$offset`(): Long {
        return `maxComputeWorkgroupSizeZ$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeZ
     * * }
     */
    fun maxComputeWorkgroupSizeZ(struct: MemorySegment): Int {
        return struct.get(`maxComputeWorkgroupSizeZ$LAYOUT`, `maxComputeWorkgroupSizeZ$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupSizeZ
     * * }
     */
    fun maxComputeWorkgroupSizeZ(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxComputeWorkgroupSizeZ$LAYOUT`, `maxComputeWorkgroupSizeZ$OFFSET`, fieldValue)
    }

    private val `maxComputeWorkgroupsPerDimension$LAYOUT` =
        `$LAYOUT`.select(groupElement("maxComputeWorkgroupsPerDimension")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupsPerDimension
     * * }
     */
    fun `maxComputeWorkgroupsPerDimension$layout`(): ValueLayout.OfInt {
        return `maxComputeWorkgroupsPerDimension$LAYOUT`
    }

    private const val `maxComputeWorkgroupsPerDimension$OFFSET`: Long = 140

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupsPerDimension
     * * }
     */
    fun `maxComputeWorkgroupsPerDimension$offset`(): Long {
        return `maxComputeWorkgroupsPerDimension$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupsPerDimension
     * * }
     */
    fun maxComputeWorkgroupsPerDimension(struct: MemorySegment): Int {
        return struct.get(`maxComputeWorkgroupsPerDimension$LAYOUT`, `maxComputeWorkgroupsPerDimension$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t maxComputeWorkgroupsPerDimension
     * * }
     */
    fun maxComputeWorkgroupsPerDimension(struct: MemorySegment, fieldValue: Int) {
        struct.set(`maxComputeWorkgroupsPerDimension$LAYOUT`, `maxComputeWorkgroupsPerDimension$OFFSET`, fieldValue)
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

