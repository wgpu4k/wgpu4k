// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.AddressLayout
import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.paddingLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUSamplerDescriptor {
 * *     const WGPUChainedStruct *nextInChain;
 * *     const char *label;
 * *     WGPUAddressMode addressModeU;
 * *     WGPUAddressMode addressModeV;
 * *     WGPUAddressMode addressModeW;
 * *     WGPUFilterMode magFilter;
 * *     WGPUFilterMode minFilter;
 * *     WGPUMipmapFilterMode mipmapFilter;
 * *     float lodMinClamp;
 * *     float lodMaxClamp;
 * *     WGPUCompareFunction compare;
 * *     uint16_t maxAnisotropy;
 * * }
 * * }
 */
object WGPUSamplerDescriptor {
    private val `$LAYOUT` = structLayout(
        wgpu_h.C_POINTER.withName("nextInChain"),
        wgpu_h.C_POINTER.withName("label"),
        wgpu_h.C_INT.withName("addressModeU"),
        wgpu_h.C_INT.withName("addressModeV"),
        wgpu_h.C_INT.withName("addressModeW"),
        wgpu_h.C_INT.withName("magFilter"),
        wgpu_h.C_INT.withName("minFilter"),
        wgpu_h.C_INT.withName("mipmapFilter"),
        wgpu_h.C_FLOAT.withName("lodMinClamp"),
        wgpu_h.C_FLOAT.withName("lodMaxClamp"),
        wgpu_h.C_INT.withName("compare"),
        wgpu_h.C_SHORT.withName("maxAnisotropy"),
        paddingLayout(2)
    ).withName("WGPUSamplerDescriptor")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `nextInChain$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("nextInChain")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$layout`(): AddressLayout {
        return `nextInChain$LAYOUT`
    }

    private const val `nextInChain$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$offset`(): Long {
        return `nextInChain$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment): MemorySegment {
        return struct.get(`nextInChain$LAYOUT`, `nextInChain$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `nextInChain$LAYOUT`, `nextInChain$OFFSET`,
            fieldValue!!
        )
    }

    private val `label$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("label")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun `label$layout`(): AddressLayout {
        return `label$LAYOUT`
    }

    private const val `label$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun `label$offset`(): Long {
        return `label$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun label(struct: MemorySegment): MemorySegment {
        return struct.get(`label$LAYOUT`, `label$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun label(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `label$LAYOUT`, `label$OFFSET`,
            fieldValue!!
        )
    }

    private val `addressModeU$LAYOUT` = `$LAYOUT`.select(groupElement("addressModeU")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeU
     * * }
     */
    fun `addressModeU$layout`(): ValueLayout.OfInt {
        return `addressModeU$LAYOUT`
    }

    private const val `addressModeU$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeU
     * * }
     */
    fun `addressModeU$offset`(): Long {
        return `addressModeU$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeU
     * * }
     */
    fun addressModeU(struct: MemorySegment): Int {
        return struct.get(`addressModeU$LAYOUT`, `addressModeU$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeU
     * * }
     */
    fun addressModeU(struct: MemorySegment, fieldValue: Int) {
        struct.set(`addressModeU$LAYOUT`, `addressModeU$OFFSET`, fieldValue)
    }

    private val `addressModeV$LAYOUT` = `$LAYOUT`.select(groupElement("addressModeV")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeV
     * * }
     */
    fun `addressModeV$layout`(): ValueLayout.OfInt {
        return `addressModeV$LAYOUT`
    }

    private const val `addressModeV$OFFSET`: Long = 20

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeV
     * * }
     */
    fun `addressModeV$offset`(): Long {
        return `addressModeV$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeV
     * * }
     */
    fun addressModeV(struct: MemorySegment): Int {
        return struct.get(`addressModeV$LAYOUT`, `addressModeV$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeV
     * * }
     */
    fun addressModeV(struct: MemorySegment, fieldValue: Int) {
        struct.set(`addressModeV$LAYOUT`, `addressModeV$OFFSET`, fieldValue)
    }

    private val `addressModeW$LAYOUT` = `$LAYOUT`.select(groupElement("addressModeW")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeW
     * * }
     */
    fun `addressModeW$layout`(): ValueLayout.OfInt {
        return `addressModeW$LAYOUT`
    }

    private const val `addressModeW$OFFSET`: Long = 24

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeW
     * * }
     */
    fun `addressModeW$offset`(): Long {
        return `addressModeW$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeW
     * * }
     */
    fun addressModeW(struct: MemorySegment): Int {
        return struct.get(`addressModeW$LAYOUT`, `addressModeW$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUAddressMode addressModeW
     * * }
     */
    fun addressModeW(struct: MemorySegment, fieldValue: Int) {
        struct.set(`addressModeW$LAYOUT`, `addressModeW$OFFSET`, fieldValue)
    }

    private val `magFilter$LAYOUT` = `$LAYOUT`.select(groupElement("magFilter")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUFilterMode magFilter
     * * }
     */
    fun `magFilter$layout`(): ValueLayout.OfInt {
        return `magFilter$LAYOUT`
    }

    private const val `magFilter$OFFSET`: Long = 28

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUFilterMode magFilter
     * * }
     */
    fun `magFilter$offset`(): Long {
        return `magFilter$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUFilterMode magFilter
     * * }
     */
    fun magFilter(struct: MemorySegment): Int {
        return struct.get(`magFilter$LAYOUT`, `magFilter$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUFilterMode magFilter
     * * }
     */
    fun magFilter(struct: MemorySegment, fieldValue: Int) {
        struct.set(`magFilter$LAYOUT`, `magFilter$OFFSET`, fieldValue)
    }

    private val `minFilter$LAYOUT` = `$LAYOUT`.select(groupElement("minFilter")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUFilterMode minFilter
     * * }
     */
    fun `minFilter$layout`(): ValueLayout.OfInt {
        return `minFilter$LAYOUT`
    }

    private const val `minFilter$OFFSET`: Long = 32

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUFilterMode minFilter
     * * }
     */
    fun `minFilter$offset`(): Long {
        return `minFilter$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUFilterMode minFilter
     * * }
     */
    fun minFilter(struct: MemorySegment): Int {
        return struct.get(`minFilter$LAYOUT`, `minFilter$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUFilterMode minFilter
     * * }
     */
    fun minFilter(struct: MemorySegment, fieldValue: Int) {
        struct.set(`minFilter$LAYOUT`, `minFilter$OFFSET`, fieldValue)
    }

    private val `mipmapFilter$LAYOUT` = `$LAYOUT`.select(groupElement("mipmapFilter")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUMipmapFilterMode mipmapFilter
     * * }
     */
    fun `mipmapFilter$layout`(): ValueLayout.OfInt {
        return `mipmapFilter$LAYOUT`
    }

    private const val `mipmapFilter$OFFSET`: Long = 36

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUMipmapFilterMode mipmapFilter
     * * }
     */
    fun `mipmapFilter$offset`(): Long {
        return `mipmapFilter$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUMipmapFilterMode mipmapFilter
     * * }
     */
    fun mipmapFilter(struct: MemorySegment): Int {
        return struct.get(`mipmapFilter$LAYOUT`, `mipmapFilter$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUMipmapFilterMode mipmapFilter
     * * }
     */
    fun mipmapFilter(struct: MemorySegment, fieldValue: Int) {
        struct.set(`mipmapFilter$LAYOUT`, `mipmapFilter$OFFSET`, fieldValue)
    }

    private val `lodMinClamp$LAYOUT` = `$LAYOUT`.select(groupElement("lodMinClamp")) as ValueLayout.OfFloat

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * float lodMinClamp
     * * }
     */
    fun `lodMinClamp$layout`(): ValueLayout.OfFloat {
        return `lodMinClamp$LAYOUT`
    }

    private const val `lodMinClamp$OFFSET`: Long = 40

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * float lodMinClamp
     * * }
     */
    fun `lodMinClamp$offset`(): Long {
        return `lodMinClamp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * float lodMinClamp
     * * }
     */
    fun lodMinClamp(struct: MemorySegment): Float {
        return struct.get(`lodMinClamp$LAYOUT`, `lodMinClamp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * float lodMinClamp
     * * }
     */
    fun lodMinClamp(struct: MemorySegment, fieldValue: Float) {
        struct.set(`lodMinClamp$LAYOUT`, `lodMinClamp$OFFSET`, fieldValue)
    }

    private val `lodMaxClamp$LAYOUT` = `$LAYOUT`.select(groupElement("lodMaxClamp")) as ValueLayout.OfFloat

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * float lodMaxClamp
     * * }
     */
    fun `lodMaxClamp$layout`(): ValueLayout.OfFloat {
        return `lodMaxClamp$LAYOUT`
    }

    private const val `lodMaxClamp$OFFSET`: Long = 44

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * float lodMaxClamp
     * * }
     */
    fun `lodMaxClamp$offset`(): Long {
        return `lodMaxClamp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * float lodMaxClamp
     * * }
     */
    fun lodMaxClamp(struct: MemorySegment): Float {
        return struct.get(`lodMaxClamp$LAYOUT`, `lodMaxClamp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * float lodMaxClamp
     * * }
     */
    fun lodMaxClamp(struct: MemorySegment, fieldValue: Float) {
        struct.set(`lodMaxClamp$LAYOUT`, `lodMaxClamp$OFFSET`, fieldValue)
    }

    private val `compare$LAYOUT` = `$LAYOUT`.select(groupElement("compare")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun `compare$layout`(): ValueLayout.OfInt {
        return `compare$LAYOUT`
    }

    private const val `compare$OFFSET`: Long = 48

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun `compare$offset`(): Long {
        return `compare$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun compare(struct: MemorySegment): Int {
        return struct.get(`compare$LAYOUT`, `compare$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun compare(struct: MemorySegment, fieldValue: Int) {
        struct.set(`compare$LAYOUT`, `compare$OFFSET`, fieldValue)
    }

    private val `maxAnisotropy$LAYOUT` = `$LAYOUT`.select(groupElement("maxAnisotropy")) as ValueLayout.OfShort

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint16_t maxAnisotropy
     * * }
     */
    fun `maxAnisotropy$layout`(): ValueLayout.OfShort {
        return `maxAnisotropy$LAYOUT`
    }

    private const val `maxAnisotropy$OFFSET`: Long = 52

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint16_t maxAnisotropy
     * * }
     */
    fun `maxAnisotropy$offset`(): Long {
        return `maxAnisotropy$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint16_t maxAnisotropy
     * * }
     */
    fun maxAnisotropy(struct: MemorySegment): Short {
        return struct.get(`maxAnisotropy$LAYOUT`, `maxAnisotropy$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint16_t maxAnisotropy
     * * }
     */
    fun maxAnisotropy(struct: MemorySegment, fieldValue: Short) {
        struct.set(`maxAnisotropy$LAYOUT`, `maxAnisotropy$OFFSET`, fieldValue)
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

