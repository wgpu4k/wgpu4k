// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.*
import java.lang.foreign.MemoryLayout.Companion.paddingLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUSurfaceCapabilities {
 * *     WGPUChainedStructOut *nextInChain;
 * *     WGPUTextureUsageFlags usages;
 * *     size_t formatCount;
 * *     const WGPUTextureFormat *formats;
 * *     size_t presentModeCount;
 * *     const WGPUPresentMode *presentModes;
 * *     size_t alphaModeCount;
 * *     const WGPUCompositeAlphaMode *alphaModes;
 * * }
 * * }
 */
object WGPUSurfaceCapabilities {
    private val `$LAYOUT` = structLayout(
        wgpu_h.C_POINTER.withName("nextInChain"),
        wgpu_h.C_INT.withName("usages"),
        paddingLayout(4),
        wgpu_h.C_LONG.withName("formatCount"),
        wgpu_h.C_POINTER.withName("formats"),
        wgpu_h.C_LONG.withName("presentModeCount"),
        wgpu_h.C_POINTER.withName("presentModes"),
        wgpu_h.C_LONG.withName("alphaModeCount"),
        wgpu_h.C_POINTER.withName("alphaModes")
    ).withName("WGPUSurfaceCapabilities")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `nextInChain$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("nextInChain"))

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUChainedStructOut *nextInChain
     * * }
     */
    fun `nextInChain$layout`(): AddressLayout {
        return `nextInChain$LAYOUT`
    }

    private const val `nextInChain$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUChainedStructOut *nextInChain
     * * }
     */
    fun `nextInChain$offset`(): Long {
        return `nextInChain$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUChainedStructOut *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment): MemorySegment {
        return struct.get(`nextInChain$LAYOUT`, `nextInChain$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUChainedStructOut *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `nextInChain$LAYOUT`, `nextInChain$OFFSET`,
            fieldValue!!
        )
    }

    private val `usages$LAYOUT` = `$LAYOUT`.select(groupElement("usages")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUTextureUsageFlags usages
     * * }
     */
    fun `usages$layout`(): ValueLayout.OfInt {
        return `usages$LAYOUT`
    }

    private const val `usages$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUTextureUsageFlags usages
     * * }
     */
    fun `usages$offset`(): Long {
        return `usages$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUTextureUsageFlags usages
     * * }
     */
    fun usages(struct: MemorySegment): Int {
        return struct.get(`usages$LAYOUT`, `usages$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUTextureUsageFlags usages
     * * }
     */
    fun usages(struct: MemorySegment, fieldValue: Int) {
        struct.set(`usages$LAYOUT`, `usages$OFFSET`, fieldValue)
    }

    private val `formatCount$LAYOUT` = `$LAYOUT`.select(groupElement("formatCount")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * size_t formatCount
     * * }
     */
    fun `formatCount$layout`(): ValueLayout.OfLong {
        return `formatCount$LAYOUT`
    }

    private const val `formatCount$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * size_t formatCount
     * * }
     */
    fun `formatCount$offset`(): Long {
        return `formatCount$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * size_t formatCount
     * * }
     */
    fun formatCount(struct: MemorySegment): Long {
        return struct.get(`formatCount$LAYOUT`, `formatCount$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * size_t formatCount
     * * }
     */
    fun formatCount(struct: MemorySegment, fieldValue: Long) {
        struct.set(`formatCount$LAYOUT`, `formatCount$OFFSET`, fieldValue)
    }

    private val `formats$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("formats"))

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUTextureFormat *formats
     * * }
     */
    fun `formats$layout`(): AddressLayout {
        return `formats$LAYOUT`
    }

    private const val `formats$OFFSET`: Long = 24

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUTextureFormat *formats
     * * }
     */
    fun `formats$offset`(): Long {
        return `formats$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUTextureFormat *formats
     * * }
     */
    fun formats(struct: MemorySegment): MemorySegment {
        return struct.get(`formats$LAYOUT`, `formats$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUTextureFormat *formats
     * * }
     */
    fun formats(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `formats$LAYOUT`, `formats$OFFSET`,
            fieldValue!!
        )
    }

    private val `presentModeCount$LAYOUT` = `$LAYOUT`.select(groupElement("presentModeCount")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * size_t presentModeCount
     * * }
     */
    fun `presentModeCount$layout`(): ValueLayout.OfLong {
        return `presentModeCount$LAYOUT`
    }

    private const val `presentModeCount$OFFSET`: Long = 32

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * size_t presentModeCount
     * * }
     */
    fun `presentModeCount$offset`(): Long {
        return `presentModeCount$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * size_t presentModeCount
     * * }
     */
    fun presentModeCount(struct: MemorySegment): Long {
        return struct.get(`presentModeCount$LAYOUT`, `presentModeCount$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * size_t presentModeCount
     * * }
     */
    fun presentModeCount(struct: MemorySegment, fieldValue: Long) {
        struct.set(`presentModeCount$LAYOUT`, `presentModeCount$OFFSET`, fieldValue)
    }

    private val `presentModes$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("presentModes"))

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUPresentMode *presentModes
     * * }
     */
    fun `presentModes$layout`(): AddressLayout {
        return `presentModes$LAYOUT`
    }

    private const val `presentModes$OFFSET`: Long = 40

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUPresentMode *presentModes
     * * }
     */
    fun `presentModes$offset`(): Long {
        return `presentModes$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUPresentMode *presentModes
     * * }
     */
    fun presentModes(struct: MemorySegment): MemorySegment {
        return struct.get(`presentModes$LAYOUT`, `presentModes$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUPresentMode *presentModes
     * * }
     */
    fun presentModes(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `presentModes$LAYOUT`, `presentModes$OFFSET`,
            fieldValue!!
        )
    }

    private val `alphaModeCount$LAYOUT` = `$LAYOUT`.select(groupElement("alphaModeCount")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * size_t alphaModeCount
     * * }
     */
    fun `alphaModeCount$layout`(): ValueLayout.OfLong {
        return `alphaModeCount$LAYOUT`
    }

    private const val `alphaModeCount$OFFSET`: Long = 48

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * size_t alphaModeCount
     * * }
     */
    fun `alphaModeCount$offset`(): Long {
        return `alphaModeCount$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * size_t alphaModeCount
     * * }
     */
    fun alphaModeCount(struct: MemorySegment): Long {
        return struct.get(`alphaModeCount$LAYOUT`, `alphaModeCount$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * size_t alphaModeCount
     * * }
     */
    fun alphaModeCount(struct: MemorySegment, fieldValue: Long) {
        struct.set(`alphaModeCount$LAYOUT`, `alphaModeCount$OFFSET`, fieldValue)
    }

    private val `alphaModes$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("alphaModes"))

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUCompositeAlphaMode *alphaModes
     * * }
     */
    fun `alphaModes$layout`(): AddressLayout {
        return `alphaModes$LAYOUT`
    }

    private const val `alphaModes$OFFSET`: Long = 56

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUCompositeAlphaMode *alphaModes
     * * }
     */
    fun `alphaModes$offset`(): Long {
        return `alphaModes$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUCompositeAlphaMode *alphaModes
     * * }
     */
    fun alphaModes(struct: MemorySegment): MemorySegment {
        return struct.get(`alphaModes$LAYOUT`, `alphaModes$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUCompositeAlphaMode *alphaModes
     * * }
     */
    fun alphaModes(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `alphaModes$LAYOUT`, `alphaModes$OFFSET`,
            fieldValue!!
        )
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

