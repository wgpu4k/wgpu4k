// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.AddressLayout
import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPURenderPassDepthStencilAttachment {
 * *     WGPUTextureView view;
 * *     WGPULoadOp depthLoadOp;
 * *     WGPUStoreOp depthStoreOp;
 * *     float depthClearValue;
 * *     WGPUBool depthReadOnly;
 * *     WGPULoadOp stencilLoadOp;
 * *     WGPUStoreOp stencilStoreOp;
 * *     uint32_t stencilClearValue;
 * *     WGPUBool stencilReadOnly;
 * * }
 * * }
 */
object WGPURenderPassDepthStencilAttachment {
    val `$LAYOUT` = structLayout(
        wgpu_h.C_POINTER.withName("view"),
        wgpu_h.C_INT.withName("depthLoadOp"),
        wgpu_h.C_INT.withName("depthStoreOp"),
        wgpu_h.C_FLOAT.withName("depthClearValue"),
        wgpu_h.C_INT.withName("depthReadOnly"),
        wgpu_h.C_INT.withName("stencilLoadOp"),
        wgpu_h.C_INT.withName("stencilStoreOp"),
        wgpu_h.C_INT.withName("stencilClearValue"),
        wgpu_h.C_INT.withName("stencilReadOnly")
    ).withName("WGPURenderPassDepthStencilAttachment")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    val `view$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("view")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUTextureView view
     * * }
     */
    fun `view$layout`(): AddressLayout {
        return `view$LAYOUT`
    }

    const val `view$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUTextureView view
     * * }
     */
    fun `view$offset`(): Long {
        return `view$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUTextureView view
     * * }
     */
    fun view(struct: MemorySegment): MemorySegment {
        return struct.get(`view$LAYOUT`, `view$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUTextureView view
     * * }
     */
    fun view(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `view$LAYOUT`, `view$OFFSET`,
            fieldValue!!
        )
    }

    val `depthLoadOp$LAYOUT` = `$LAYOUT`.select(groupElement("depthLoadOp")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPULoadOp depthLoadOp
     * * }
     */
    fun `depthLoadOp$layout`(): ValueLayout.OfInt {
        return `depthLoadOp$LAYOUT`
    }

    const val `depthLoadOp$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPULoadOp depthLoadOp
     * * }
     */
    fun `depthLoadOp$offset`(): Long {
        return `depthLoadOp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPULoadOp depthLoadOp
     * * }
     */
    fun depthLoadOp(struct: MemorySegment): Int {
        return struct.get(`depthLoadOp$LAYOUT`, `depthLoadOp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPULoadOp depthLoadOp
     * * }
     */
    fun depthLoadOp(struct: MemorySegment, fieldValue: Int) {
        struct.set(`depthLoadOp$LAYOUT`, `depthLoadOp$OFFSET`, fieldValue)
    }

    val `depthStoreOp$LAYOUT` = `$LAYOUT`.select(groupElement("depthStoreOp")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStoreOp depthStoreOp
     * * }
     */
    fun `depthStoreOp$layout`(): ValueLayout.OfInt {
        return `depthStoreOp$LAYOUT`
    }

    const val `depthStoreOp$OFFSET`: Long = 12

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStoreOp depthStoreOp
     * * }
     */
    fun `depthStoreOp$offset`(): Long {
        return `depthStoreOp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStoreOp depthStoreOp
     * * }
     */
    fun depthStoreOp(struct: MemorySegment): Int {
        return struct.get(`depthStoreOp$LAYOUT`, `depthStoreOp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStoreOp depthStoreOp
     * * }
     */
    fun depthStoreOp(struct: MemorySegment, fieldValue: Int) {
        struct.set(`depthStoreOp$LAYOUT`, `depthStoreOp$OFFSET`, fieldValue)
    }

    val `depthClearValue$LAYOUT` = `$LAYOUT`.select(groupElement("depthClearValue")) as ValueLayout.OfFloat

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * float depthClearValue
     * * }
     */
    fun `depthClearValue$layout`(): ValueLayout.OfFloat {
        return `depthClearValue$LAYOUT`
    }

    const val `depthClearValue$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * float depthClearValue
     * * }
     */
    fun `depthClearValue$offset`(): Long {
        return `depthClearValue$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * float depthClearValue
     * * }
     */
    fun depthClearValue(struct: MemorySegment): Float {
        return struct.get(`depthClearValue$LAYOUT`, `depthClearValue$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * float depthClearValue
     * * }
     */
    fun depthClearValue(struct: MemorySegment, fieldValue: Float) {
        struct.set(`depthClearValue$LAYOUT`, `depthClearValue$OFFSET`, fieldValue)
    }

    val `depthReadOnly$LAYOUT` = `$LAYOUT`.select(groupElement("depthReadOnly")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUBool depthReadOnly
     * * }
     */
    fun `depthReadOnly$layout`(): ValueLayout.OfInt {
        return `depthReadOnly$LAYOUT`
    }

    const val `depthReadOnly$OFFSET`: Long = 20

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUBool depthReadOnly
     * * }
     */
    fun `depthReadOnly$offset`(): Long {
        return `depthReadOnly$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUBool depthReadOnly
     * * }
     */
    fun depthReadOnly(struct: MemorySegment): Int {
        return struct.get(`depthReadOnly$LAYOUT`, `depthReadOnly$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUBool depthReadOnly
     * * }
     */
    fun depthReadOnly(struct: MemorySegment, fieldValue: Int) {
        struct.set(`depthReadOnly$LAYOUT`, `depthReadOnly$OFFSET`, fieldValue)
    }

    val `stencilLoadOp$LAYOUT` = `$LAYOUT`.select(groupElement("stencilLoadOp")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPULoadOp stencilLoadOp
     * * }
     */
    fun `stencilLoadOp$layout`(): ValueLayout.OfInt {
        return `stencilLoadOp$LAYOUT`
    }

    const val `stencilLoadOp$OFFSET`: Long = 24

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPULoadOp stencilLoadOp
     * * }
     */
    fun `stencilLoadOp$offset`(): Long {
        return `stencilLoadOp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPULoadOp stencilLoadOp
     * * }
     */
    fun stencilLoadOp(struct: MemorySegment): Int {
        return struct.get(`stencilLoadOp$LAYOUT`, `stencilLoadOp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPULoadOp stencilLoadOp
     * * }
     */
    fun stencilLoadOp(struct: MemorySegment, fieldValue: Int) {
        struct.set(`stencilLoadOp$LAYOUT`, `stencilLoadOp$OFFSET`, fieldValue)
    }

    val `stencilStoreOp$LAYOUT` = `$LAYOUT`.select(groupElement("stencilStoreOp")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStoreOp stencilStoreOp
     * * }
     */
    fun `stencilStoreOp$layout`(): ValueLayout.OfInt {
        return `stencilStoreOp$LAYOUT`
    }

    const val `stencilStoreOp$OFFSET`: Long = 28

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStoreOp stencilStoreOp
     * * }
     */
    fun `stencilStoreOp$offset`(): Long {
        return `stencilStoreOp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStoreOp stencilStoreOp
     * * }
     */
    fun stencilStoreOp(struct: MemorySegment): Int {
        return struct.get(`stencilStoreOp$LAYOUT`, `stencilStoreOp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStoreOp stencilStoreOp
     * * }
     */
    fun stencilStoreOp(struct: MemorySegment, fieldValue: Int) {
        struct.set(`stencilStoreOp$LAYOUT`, `stencilStoreOp$OFFSET`, fieldValue)
    }

    val `stencilClearValue$LAYOUT` = `$LAYOUT`.select(groupElement("stencilClearValue")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t stencilClearValue
     * * }
     */
    fun `stencilClearValue$layout`(): ValueLayout.OfInt {
        return `stencilClearValue$LAYOUT`
    }

    const val `stencilClearValue$OFFSET`: Long = 32

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t stencilClearValue
     * * }
     */
    fun `stencilClearValue$offset`(): Long {
        return `stencilClearValue$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t stencilClearValue
     * * }
     */
    fun stencilClearValue(struct: MemorySegment): Int {
        return struct.get(`stencilClearValue$LAYOUT`, `stencilClearValue$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t stencilClearValue
     * * }
     */
    fun stencilClearValue(struct: MemorySegment, fieldValue: Int) {
        struct.set(`stencilClearValue$LAYOUT`, `stencilClearValue$OFFSET`, fieldValue)
    }

    val `stencilReadOnly$LAYOUT` = `$LAYOUT`.select(groupElement("stencilReadOnly")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUBool stencilReadOnly
     * * }
     */
    fun `stencilReadOnly$layout`(): ValueLayout.OfInt {
        return `stencilReadOnly$LAYOUT`
    }

    const val `stencilReadOnly$OFFSET`: Long = 36

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUBool stencilReadOnly
     * * }
     */
    fun `stencilReadOnly$offset`(): Long {
        return `stencilReadOnly$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUBool stencilReadOnly
     * * }
     */
    fun stencilReadOnly(struct: MemorySegment): Int {
        return struct.get(`stencilReadOnly$LAYOUT`, `stencilReadOnly$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUBool stencilReadOnly
     * * }
     */
    fun stencilReadOnly(struct: MemorySegment, fieldValue: Int) {
        struct.set(`stencilReadOnly$LAYOUT`, `stencilReadOnly$OFFSET`, fieldValue)
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

