// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUStencilFaceState {
 * *     WGPUCompareFunction compare;
 * *     WGPUStencilOperation failOp;
 * *     WGPUStencilOperation depthFailOp;
 * *     WGPUStencilOperation passOp;
 * * }
 * * }
 */
object WGPUStencilFaceState {
    private val `$LAYOUT` = structLayout(
        wgpu_h.C_INT.withName("compare"),
        wgpu_h.C_INT.withName("failOp"),
        wgpu_h.C_INT.withName("depthFailOp"),
        wgpu_h.C_INT.withName("passOp")
    ).withName("WGPUStencilFaceState")

    /**
     * The layout of this struct
     */
    @JvmStatic
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `compare$LAYOUT` = `$LAYOUT`.select(groupElement("compare")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun `compare$layout`(): ValueLayout.OfInt {
        return `compare$LAYOUT`
    }

    private const val `compare$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun `compare$offset`(): Long {
        return `compare$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun compare(struct: MemorySegment): Int {
        return struct.get(`compare$LAYOUT`, `compare$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction compare
     * * }
     */
    fun compare(struct: MemorySegment, fieldValue: Int) {
        struct.set(`compare$LAYOUT`, `compare$OFFSET`, fieldValue)
    }

    private val `failOp$LAYOUT` = `$LAYOUT`.select(groupElement("failOp")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation failOp
     * * }
     */
    fun `failOp$layout`(): ValueLayout.OfInt {
        return `failOp$LAYOUT`
    }

    private const val `failOp$OFFSET`: Long = 4

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation failOp
     * * }
     */
    fun `failOp$offset`(): Long {
        return `failOp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation failOp
     * * }
     */
    fun failOp(struct: MemorySegment): Int {
        return struct.get(`failOp$LAYOUT`, `failOp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation failOp
     * * }
     */
    fun failOp(struct: MemorySegment, fieldValue: Int) {
        struct.set(`failOp$LAYOUT`, `failOp$OFFSET`, fieldValue)
    }

    private val `depthFailOp$LAYOUT` = `$LAYOUT`.select(groupElement("depthFailOp")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation depthFailOp
     * * }
     */
    fun `depthFailOp$layout`(): ValueLayout.OfInt {
        return `depthFailOp$LAYOUT`
    }

    private const val `depthFailOp$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation depthFailOp
     * * }
     */
    fun `depthFailOp$offset`(): Long {
        return `depthFailOp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation depthFailOp
     * * }
     */
    fun depthFailOp(struct: MemorySegment): Int {
        return struct.get(`depthFailOp$LAYOUT`, `depthFailOp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation depthFailOp
     * * }
     */
    fun depthFailOp(struct: MemorySegment, fieldValue: Int) {
        struct.set(`depthFailOp$LAYOUT`, `depthFailOp$OFFSET`, fieldValue)
    }

    private val `passOp$LAYOUT` = `$LAYOUT`.select(groupElement("passOp")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation passOp
     * * }
     */
    fun `passOp$layout`(): ValueLayout.OfInt {
        return `passOp$LAYOUT`
    }

    private const val `passOp$OFFSET`: Long = 12

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation passOp
     * * }
     */
    fun `passOp$offset`(): Long {
        return `passOp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation passOp
     * * }
     */
    fun passOp(struct: MemorySegment): Int {
        return struct.get(`passOp$LAYOUT`, `passOp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStencilOperation passOp
     * * }
     */
    fun passOp(struct: MemorySegment, fieldValue: Int) {
        struct.set(`passOp$LAYOUT`, `passOp$OFFSET`, fieldValue)
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

