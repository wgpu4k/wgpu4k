// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.AddressLayout
import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUInstanceExtras {
 * *     WGPUChainedStruct chain;
 * *     WGPUInstanceBackendFlags backends;
 * *     WGPUInstanceFlags flags;
 * *     WGPUDx12Compiler dx12ShaderCompiler;
 * *     WGPUGles3MinorVersion gles3MinorVersion;
 * *     const char *dxilPath;
 * *     const char *dxcPath;
 * * }
 * * }
 */
object WGPUInstanceExtras {
    private val `$LAYOUT` = structLayout(
        WGPUChainedStruct.layout().withName("chain"),
        wgpu_h.C_INT.withName("backends"),
        wgpu_h.C_INT.withName("flags"),
        wgpu_h.C_INT.withName("dx12ShaderCompiler"),
        wgpu_h.C_INT.withName("gles3MinorVersion"),
        wgpu_h.C_POINTER.withName("dxilPath"),
        wgpu_h.C_POINTER.withName("dxcPath")
    ).withName("WGPUInstanceExtras")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `chain$LAYOUT` = `$LAYOUT`.select(groupElement("chain")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUChainedStruct chain
     * * }
     */
    fun `chain$layout`(): GroupLayout? {
        return `chain$LAYOUT`
    }

    private const val `chain$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUChainedStruct chain
     * * }
     */
    fun `chain$offset`(): Long {
        return `chain$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUChainedStruct chain
     * * }
     */
    fun chain(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`chain$OFFSET`, `chain$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUChainedStruct chain
     * * }
     */
    fun chain(struct: MemorySegment, fieldValue: MemorySegment) {
        MemorySegment.copy(fieldValue, 0L, struct, `chain$OFFSET`, `chain$LAYOUT`.byteSize())
    }

    private val `backends$LAYOUT` = `$LAYOUT`.select(groupElement("backends")) as ValueLayout.OfInt?

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUInstanceBackendFlags backends
     * * }
     */
    fun `backends$layout`(): ValueLayout.OfInt? {
        return `backends$LAYOUT`
    }

    private const val `backends$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUInstanceBackendFlags backends
     * * }
     */
    fun `backends$offset`(): Long {
        return `backends$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUInstanceBackendFlags backends
     * * }
     */
    fun backends(struct: MemorySegment): Int {
        return struct.get(`backends$LAYOUT`, `backends$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUInstanceBackendFlags backends
     * * }
     */
    fun backends(struct: MemorySegment, fieldValue: Int) {
        struct.set(`backends$LAYOUT`, `backends$OFFSET`, fieldValue)
    }

    private val `flags$LAYOUT` = `$LAYOUT`.select(groupElement("flags")) as ValueLayout.OfInt?

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUInstanceFlags flags
     * * }
     */
    fun `flags$layout`(): ValueLayout.OfInt? {
        return `flags$LAYOUT`
    }

    private const val `flags$OFFSET`: Long = 20

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUInstanceFlags flags
     * * }
     */
    fun `flags$offset`(): Long {
        return `flags$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUInstanceFlags flags
     * * }
     */
    fun flags(struct: MemorySegment): Int {
        return struct.get(`flags$LAYOUT`, `flags$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUInstanceFlags flags
     * * }
     */
    fun flags(struct: MemorySegment, fieldValue: Int) {
        struct.set(`flags$LAYOUT`, `flags$OFFSET`, fieldValue)
    }

    private val `dx12ShaderCompiler$LAYOUT` = `$LAYOUT`.select(groupElement("dx12ShaderCompiler")) as ValueLayout.OfInt?

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUDx12Compiler dx12ShaderCompiler
     * * }
     */
    fun `dx12ShaderCompiler$layout`(): ValueLayout.OfInt? {
        return `dx12ShaderCompiler$LAYOUT`
    }

    private const val `dx12ShaderCompiler$OFFSET`: Long = 24

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUDx12Compiler dx12ShaderCompiler
     * * }
     */
    fun `dx12ShaderCompiler$offset`(): Long {
        return `dx12ShaderCompiler$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUDx12Compiler dx12ShaderCompiler
     * * }
     */
    fun dx12ShaderCompiler(struct: MemorySegment): Int {
        return struct.get(`dx12ShaderCompiler$LAYOUT`, `dx12ShaderCompiler$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUDx12Compiler dx12ShaderCompiler
     * * }
     */
    fun dx12ShaderCompiler(struct: MemorySegment, fieldValue: Int) {
        struct.set(`dx12ShaderCompiler$LAYOUT`, `dx12ShaderCompiler$OFFSET`, fieldValue)
    }

    private val `gles3MinorVersion$LAYOUT` = `$LAYOUT`.select(groupElement("gles3MinorVersion")) as ValueLayout.OfInt?

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUGles3MinorVersion gles3MinorVersion
     * * }
     */
    fun `gles3MinorVersion$layout`(): ValueLayout.OfInt? {
        return `gles3MinorVersion$LAYOUT`
    }

    private const val `gles3MinorVersion$OFFSET`: Long = 28

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUGles3MinorVersion gles3MinorVersion
     * * }
     */
    fun `gles3MinorVersion$offset`(): Long {
        return `gles3MinorVersion$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUGles3MinorVersion gles3MinorVersion
     * * }
     */
    fun gles3MinorVersion(struct: MemorySegment): Int {
        return struct.get(`gles3MinorVersion$LAYOUT`, `gles3MinorVersion$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUGles3MinorVersion gles3MinorVersion
     * * }
     */
    fun gles3MinorVersion(struct: MemorySegment, fieldValue: Int) {
        struct.set(`gles3MinorVersion$LAYOUT`, `gles3MinorVersion$OFFSET`, fieldValue)
    }

    private val `dxilPath$LAYOUT` = `$LAYOUT`.select(groupElement("dxilPath")) as AddressLayout?

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const char *dxilPath
     * * }
     */
    fun `dxilPath$layout`(): AddressLayout? {
        return `dxilPath$LAYOUT`
    }

    private const val `dxilPath$OFFSET`: Long = 32

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const char *dxilPath
     * * }
     */
    fun `dxilPath$offset`(): Long {
        return `dxilPath$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const char *dxilPath
     * * }
     */
    fun dxilPath(struct: MemorySegment): MemorySegment {
        return struct.get(`dxilPath$LAYOUT`, `dxilPath$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const char *dxilPath
     * * }
     */
    fun dxilPath(struct: MemorySegment, fieldValue: MemorySegment) {
        struct.set(`dxilPath$LAYOUT`, `dxilPath$OFFSET`, fieldValue)
    }

    private val `dxcPath$LAYOUT` = `$LAYOUT`.select(groupElement("dxcPath")) as AddressLayout?

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const char *dxcPath
     * * }
     */
    fun `dxcPath$layout`(): AddressLayout? {
        return `dxcPath$LAYOUT`
    }

    private const val `dxcPath$OFFSET`: Long = 40

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const char *dxcPath
     * * }
     */
    fun `dxcPath$offset`(): Long {
        return `dxcPath$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const char *dxcPath
     * * }
     */
    fun dxcPath(struct: MemorySegment): MemorySegment {
        return struct.get(`dxcPath$LAYOUT`, `dxcPath$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const char *dxcPath
     * * }
     */
    fun dxcPath(struct: MemorySegment, fieldValue: MemorySegment) {
        struct.set(`dxcPath$LAYOUT`, `dxcPath$OFFSET`, fieldValue)
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

