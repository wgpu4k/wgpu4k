// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.AddressLayout
import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUDeviceDescriptor {
 * *     const WGPUChainedStruct *nextInChain;
 * *     const char *label;
 * *     size_t requiredFeatureCount;
 * *     const WGPUFeatureName *requiredFeatures;
 * *     const WGPURequiredLimits *requiredLimits;
 * *     WGPUQueueDescriptor defaultQueue;
 * *     WGPUDeviceLostCallback deviceLostCallback;
 * *     void *deviceLostUserdata;
 * *     WGPUUncapturedErrorCallbackInfo uncapturedErrorCallbackInfo;
 * * }
 * * }
 */
object WGPUDeviceDescriptor {
    val `$LAYOUT` = structLayout(
        wgpu_h.C_POINTER.withName("nextInChain"),
        wgpu_h.C_POINTER.withName("label"),
        wgpu_h.C_LONG.withName("requiredFeatureCount"),
        wgpu_h.C_POINTER.withName("requiredFeatures"),
        wgpu_h.C_POINTER.withName("requiredLimits"),
        WGPUQueueDescriptor.layout().withName("defaultQueue"),
        wgpu_h.C_POINTER.withName("deviceLostCallback"),
        wgpu_h.C_POINTER.withName("deviceLostUserdata"),
        WGPUUncapturedErrorCallbackInfo.layout().withName("uncapturedErrorCallbackInfo")
    ).withName("WGPUDeviceDescriptor")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    val `nextInChain$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("nextInChain")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$layout`(): AddressLayout {
        return `nextInChain$LAYOUT`
    }

    const val `nextInChain$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$offset`(): Long {
        return `nextInChain$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment): MemorySegment {
        return struct.get(`nextInChain$LAYOUT`, `nextInChain$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `nextInChain$LAYOUT`, `nextInChain$OFFSET`,
            fieldValue!!
        )
    }

    val `label$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("label")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun `label$layout`(): AddressLayout {
        return `label$LAYOUT`
    }

    const val `label$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun `label$offset`(): Long {
        return `label$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun label(struct: MemorySegment): MemorySegment {
        return struct.get(`label$LAYOUT`, `label$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const char *label
     * * }
     */
    fun label(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `label$LAYOUT`, `label$OFFSET`,
            fieldValue!!
        )
    }

    val `requiredFeatureCount$LAYOUT` =
        `$LAYOUT`.select(groupElement("requiredFeatureCount")) as ValueLayout.OfLong

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * size_t requiredFeatureCount
     * * }
     */
    fun `requiredFeatureCount$layout`(): ValueLayout.OfLong {
        return `requiredFeatureCount$LAYOUT`
    }

    const val `requiredFeatureCount$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * size_t requiredFeatureCount
     * * }
     */
    fun `requiredFeatureCount$offset`(): Long {
        return `requiredFeatureCount$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * size_t requiredFeatureCount
     * * }
     */
    fun requiredFeatureCount(struct: MemorySegment): Long {
        return struct.get(`requiredFeatureCount$LAYOUT`, `requiredFeatureCount$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * size_t requiredFeatureCount
     * * }
     */
    fun requiredFeatureCount(struct: MemorySegment, fieldValue: Long) {
        struct.set(`requiredFeatureCount$LAYOUT`, `requiredFeatureCount$OFFSET`, fieldValue)
    }

    val `requiredFeatures$LAYOUT`: AddressLayout =
        `$LAYOUT`.select(groupElement("requiredFeatures")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUFeatureName *requiredFeatures
     * * }
     */
    fun `requiredFeatures$layout`(): AddressLayout {
        return `requiredFeatures$LAYOUT`
    }

    const val `requiredFeatures$OFFSET`: Long = 24

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUFeatureName *requiredFeatures
     * * }
     */
    fun `requiredFeatures$offset`(): Long {
        return `requiredFeatures$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUFeatureName *requiredFeatures
     * * }
     */
    fun requiredFeatures(struct: MemorySegment): MemorySegment {
        return struct.get(`requiredFeatures$LAYOUT`, `requiredFeatures$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUFeatureName *requiredFeatures
     * * }
     */
    fun requiredFeatures(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `requiredFeatures$LAYOUT`, `requiredFeatures$OFFSET`,
            fieldValue!!
        )
    }

    val `requiredLimits$LAYOUT`: AddressLayout =
        `$LAYOUT`.select(groupElement("requiredLimits")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPURequiredLimits *requiredLimits
     * * }
     */
    fun `requiredLimits$layout`(): AddressLayout {
        return `requiredLimits$LAYOUT`
    }

    const val `requiredLimits$OFFSET`: Long = 32

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPURequiredLimits *requiredLimits
     * * }
     */
    fun `requiredLimits$offset`(): Long {
        return `requiredLimits$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPURequiredLimits *requiredLimits
     * * }
     */
    fun requiredLimits(struct: MemorySegment): MemorySegment {
        return struct.get(`requiredLimits$LAYOUT`, `requiredLimits$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPURequiredLimits *requiredLimits
     * * }
     */
    fun requiredLimits(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `requiredLimits$LAYOUT`, `requiredLimits$OFFSET`,
            fieldValue!!
        )
    }

    val `defaultQueue$LAYOUT` = `$LAYOUT`.select(groupElement("defaultQueue")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUQueueDescriptor defaultQueue
     * * }
     */
    fun `defaultQueue$layout`(): GroupLayout {
        return `defaultQueue$LAYOUT`
    }

    const val `defaultQueue$OFFSET`: Long = 40

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUQueueDescriptor defaultQueue
     * * }
     */
    fun `defaultQueue$offset`(): Long {
        return `defaultQueue$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUQueueDescriptor defaultQueue
     * * }
     */
    fun defaultQueue(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`defaultQueue$OFFSET`, `defaultQueue$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUQueueDescriptor defaultQueue
     * * }
     */
    fun defaultQueue(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `defaultQueue$OFFSET`, `defaultQueue$LAYOUT`.byteSize()
        )
    }

    val `deviceLostCallback$LAYOUT`: AddressLayout =
        `$LAYOUT`.select(groupElement("deviceLostCallback")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUDeviceLostCallback deviceLostCallback
     * * }
     */
    fun `deviceLostCallback$layout`(): AddressLayout {
        return `deviceLostCallback$LAYOUT`
    }

    const val `deviceLostCallback$OFFSET`: Long = 56

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUDeviceLostCallback deviceLostCallback
     * * }
     */
    fun `deviceLostCallback$offset`(): Long {
        return `deviceLostCallback$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUDeviceLostCallback deviceLostCallback
     * * }
     */
    fun deviceLostCallback(struct: MemorySegment): MemorySegment {
        return struct.get(`deviceLostCallback$LAYOUT`, `deviceLostCallback$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUDeviceLostCallback deviceLostCallback
     * * }
     */
    fun deviceLostCallback(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `deviceLostCallback$LAYOUT`, `deviceLostCallback$OFFSET`,
            fieldValue!!
        )
    }

    val `deviceLostUserdata$LAYOUT`: AddressLayout =
        `$LAYOUT`.select(groupElement("deviceLostUserdata")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * void *deviceLostUserdata
     * * }
     */
    fun `deviceLostUserdata$layout`(): AddressLayout {
        return `deviceLostUserdata$LAYOUT`
    }

    const val `deviceLostUserdata$OFFSET`: Long = 64

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * void *deviceLostUserdata
     * * }
     */
    fun `deviceLostUserdata$offset`(): Long {
        return `deviceLostUserdata$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * void *deviceLostUserdata
     * * }
     */
    fun deviceLostUserdata(struct: MemorySegment): MemorySegment {
        return struct.get(`deviceLostUserdata$LAYOUT`, `deviceLostUserdata$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * void *deviceLostUserdata
     * * }
     */
    fun deviceLostUserdata(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `deviceLostUserdata$LAYOUT`, `deviceLostUserdata$OFFSET`,
            fieldValue!!
        )
    }

    val `uncapturedErrorCallbackInfo$LAYOUT` =
        `$LAYOUT`.select(groupElement("uncapturedErrorCallbackInfo")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUUncapturedErrorCallbackInfo uncapturedErrorCallbackInfo
     * * }
     */
    fun `uncapturedErrorCallbackInfo$layout`(): GroupLayout {
        return `uncapturedErrorCallbackInfo$LAYOUT`
    }

    const val `uncapturedErrorCallbackInfo$OFFSET`: Long = 72

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUUncapturedErrorCallbackInfo uncapturedErrorCallbackInfo
     * * }
     */
    fun `uncapturedErrorCallbackInfo$offset`(): Long {
        return `uncapturedErrorCallbackInfo$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUUncapturedErrorCallbackInfo uncapturedErrorCallbackInfo
     * * }
     */
    fun uncapturedErrorCallbackInfo(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`uncapturedErrorCallbackInfo$OFFSET`, `uncapturedErrorCallbackInfo$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUUncapturedErrorCallbackInfo uncapturedErrorCallbackInfo
     * * }
     */
    fun uncapturedErrorCallbackInfo(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `uncapturedErrorCallbackInfo$OFFSET`, `uncapturedErrorCallbackInfo$LAYOUT`.byteSize()
        )
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

