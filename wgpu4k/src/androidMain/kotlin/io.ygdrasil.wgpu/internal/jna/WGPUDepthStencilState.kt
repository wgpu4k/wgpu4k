// Generated by jextract
package io.ygdrasil.wgpu.internal.jna

import java.lang.foreign.AddressLayout
import java.lang.foreign.Arena
import java.lang.foreign.GroupLayout
import java.lang.foreign.MemoryLayout.Companion.sequenceLayout
import java.lang.foreign.MemoryLayout.Companion.structLayout
import java.lang.foreign.MemoryLayout.PathElement.groupElement
import java.lang.foreign.MemorySegment
import java.lang.foreign.SegmentAllocator
import java.lang.foreign.ValueLayout
import java.util.function.Consumer

/**
 * {@snippet lang=c :
 * * struct WGPUDepthStencilState {
 * *     const WGPUChainedStruct *nextInChain;
 * *     WGPUTextureFormat format;
 * *     WGPUBool depthWriteEnabled;
 * *     WGPUCompareFunction depthCompare;
 * *     WGPUStencilFaceState stencilFront;
 * *     WGPUStencilFaceState stencilBack;
 * *     uint32_t stencilReadMask;
 * *     uint32_t stencilWriteMask;
 * *     int32_t depthBias;
 * *     float depthBiasSlopeScale;
 * *     float depthBiasClamp;
 * * }
 * * }
 */
object WGPUDepthStencilState {
    private val `$LAYOUT` = structLayout(
        wgpu_h.C_POINTER.withName("nextInChain"),
        wgpu_h.C_INT.withName("format"),
        wgpu_h.C_INT.withName("depthWriteEnabled"),
        wgpu_h.C_INT.withName("depthCompare"),
        WGPUStencilFaceState.layout().withName("stencilFront"),
        WGPUStencilFaceState.layout().withName("stencilBack"),
        wgpu_h.C_INT.withName("stencilReadMask"),
        wgpu_h.C_INT.withName("stencilWriteMask"),
        wgpu_h.C_INT.withName("depthBias"),
        wgpu_h.C_FLOAT.withName("depthBiasSlopeScale"),
        wgpu_h.C_FLOAT.withName("depthBiasClamp")
    ).withName("WGPUDepthStencilState")

    /**
     * The layout of this struct
     */
    fun layout(): GroupLayout {
        return `$LAYOUT`
    }

    private val `nextInChain$LAYOUT`: AddressLayout = `$LAYOUT`.select(groupElement("nextInChain")) as AddressLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$layout`(): AddressLayout {
        return `nextInChain$LAYOUT`
    }

    private const val `nextInChain$OFFSET`: Long = 0

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun `nextInChain$offset`(): Long {
        return `nextInChain$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment): MemorySegment {
        return struct.get(`nextInChain$LAYOUT`, `nextInChain$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * const WGPUChainedStruct *nextInChain
     * * }
     */
    fun nextInChain(struct: MemorySegment, fieldValue: MemorySegment?) {
        struct.set(
            `nextInChain$LAYOUT`, `nextInChain$OFFSET`,
            fieldValue!!
        )
    }

    private val `format$LAYOUT` = `$LAYOUT`.select(groupElement("format")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUTextureFormat format
     * * }
     */
    fun `format$layout`(): ValueLayout.OfInt {
        return `format$LAYOUT`
    }

    private const val `format$OFFSET`: Long = 8

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUTextureFormat format
     * * }
     */
    fun `format$offset`(): Long {
        return `format$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUTextureFormat format
     * * }
     */
    fun format(struct: MemorySegment): Int {
        return struct.get(`format$LAYOUT`, `format$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUTextureFormat format
     * * }
     */
    fun format(struct: MemorySegment, fieldValue: Int) {
        struct.set(`format$LAYOUT`, `format$OFFSET`, fieldValue)
    }

    private val `depthWriteEnabled$LAYOUT` = `$LAYOUT`.select(groupElement("depthWriteEnabled")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUBool depthWriteEnabled
     * * }
     */
    fun `depthWriteEnabled$layout`(): ValueLayout.OfInt {
        return `depthWriteEnabled$LAYOUT`
    }

    private const val `depthWriteEnabled$OFFSET`: Long = 12

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUBool depthWriteEnabled
     * * }
     */
    fun `depthWriteEnabled$offset`(): Long {
        return `depthWriteEnabled$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUBool depthWriteEnabled
     * * }
     */
    fun depthWriteEnabled(struct: MemorySegment): Int {
        return struct.get(`depthWriteEnabled$LAYOUT`, `depthWriteEnabled$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUBool depthWriteEnabled
     * * }
     */
    fun depthWriteEnabled(struct: MemorySegment, fieldValue: Int) {
        struct.set(`depthWriteEnabled$LAYOUT`, `depthWriteEnabled$OFFSET`, fieldValue)
    }

    private val `depthCompare$LAYOUT` = `$LAYOUT`.select(groupElement("depthCompare")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction depthCompare
     * * }
     */
    fun `depthCompare$layout`(): ValueLayout.OfInt {
        return `depthCompare$LAYOUT`
    }

    private const val `depthCompare$OFFSET`: Long = 16

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction depthCompare
     * * }
     */
    fun `depthCompare$offset`(): Long {
        return `depthCompare$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction depthCompare
     * * }
     */
    fun depthCompare(struct: MemorySegment): Int {
        return struct.get(`depthCompare$LAYOUT`, `depthCompare$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUCompareFunction depthCompare
     * * }
     */
    fun depthCompare(struct: MemorySegment, fieldValue: Int) {
        struct.set(`depthCompare$LAYOUT`, `depthCompare$OFFSET`, fieldValue)
    }

    private val `stencilFront$LAYOUT` = `$LAYOUT`.select(groupElement("stencilFront")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilFront
     * * }
     */
    fun `stencilFront$layout`(): GroupLayout {
        return `stencilFront$LAYOUT`
    }

    private const val `stencilFront$OFFSET`: Long = 20

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilFront
     * * }
     */
    fun `stencilFront$offset`(): Long {
        return `stencilFront$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilFront
     * * }
     */
    fun stencilFront(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`stencilFront$OFFSET`, `stencilFront$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilFront
     * * }
     */
    fun stencilFront(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `stencilFront$OFFSET`, `stencilFront$LAYOUT`.byteSize()
        )
    }

    private val `stencilBack$LAYOUT` = `$LAYOUT`.select(groupElement("stencilBack")) as GroupLayout

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilBack
     * * }
     */
    fun `stencilBack$layout`(): GroupLayout {
        return `stencilBack$LAYOUT`
    }

    private const val `stencilBack$OFFSET`: Long = 36

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilBack
     * * }
     */
    fun `stencilBack$offset`(): Long {
        return `stencilBack$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilBack
     * * }
     */
    fun stencilBack(struct: MemorySegment): MemorySegment {
        return struct.asSlice(`stencilBack$OFFSET`, `stencilBack$LAYOUT`.byteSize())
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * WGPUStencilFaceState stencilBack
     * * }
     */
    fun stencilBack(struct: MemorySegment?, fieldValue: MemorySegment?) {
        MemorySegment.copy(
            fieldValue!!, 0L,
            struct!!, `stencilBack$OFFSET`, `stencilBack$LAYOUT`.byteSize()
        )
    }

    private val `stencilReadMask$LAYOUT` = `$LAYOUT`.select(groupElement("stencilReadMask")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t stencilReadMask
     * * }
     */
    fun `stencilReadMask$layout`(): ValueLayout.OfInt {
        return `stencilReadMask$LAYOUT`
    }

    private const val `stencilReadMask$OFFSET`: Long = 52

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t stencilReadMask
     * * }
     */
    fun `stencilReadMask$offset`(): Long {
        return `stencilReadMask$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t stencilReadMask
     * * }
     */
    fun stencilReadMask(struct: MemorySegment): Int {
        return struct.get(`stencilReadMask$LAYOUT`, `stencilReadMask$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t stencilReadMask
     * * }
     */
    fun stencilReadMask(struct: MemorySegment, fieldValue: Int) {
        struct.set(`stencilReadMask$LAYOUT`, `stencilReadMask$OFFSET`, fieldValue)
    }

    private val `stencilWriteMask$LAYOUT` = `$LAYOUT`.select(groupElement("stencilWriteMask")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * uint32_t stencilWriteMask
     * * }
     */
    fun `stencilWriteMask$layout`(): ValueLayout.OfInt {
        return `stencilWriteMask$LAYOUT`
    }

    private const val `stencilWriteMask$OFFSET`: Long = 56

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * uint32_t stencilWriteMask
     * * }
     */
    fun `stencilWriteMask$offset`(): Long {
        return `stencilWriteMask$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * uint32_t stencilWriteMask
     * * }
     */
    fun stencilWriteMask(struct: MemorySegment): Int {
        return struct.get(`stencilWriteMask$LAYOUT`, `stencilWriteMask$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * uint32_t stencilWriteMask
     * * }
     */
    fun stencilWriteMask(struct: MemorySegment, fieldValue: Int) {
        struct.set(`stencilWriteMask$LAYOUT`, `stencilWriteMask$OFFSET`, fieldValue)
    }

    private val `depthBias$LAYOUT` = `$LAYOUT`.select(groupElement("depthBias")) as ValueLayout.OfInt

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * int32_t depthBias
     * * }
     */
    fun `depthBias$layout`(): ValueLayout.OfInt {
        return `depthBias$LAYOUT`
    }

    private const val `depthBias$OFFSET`: Long = 60

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * int32_t depthBias
     * * }
     */
    fun `depthBias$offset`(): Long {
        return `depthBias$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * int32_t depthBias
     * * }
     */
    fun depthBias(struct: MemorySegment): Int {
        return struct.get(`depthBias$LAYOUT`, `depthBias$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * int32_t depthBias
     * * }
     */
    fun depthBias(struct: MemorySegment, fieldValue: Int) {
        struct.set(`depthBias$LAYOUT`, `depthBias$OFFSET`, fieldValue)
    }

    private val `depthBiasSlopeScale$LAYOUT` =
        `$LAYOUT`.select(groupElement("depthBiasSlopeScale")) as ValueLayout.OfFloat

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * float depthBiasSlopeScale
     * * }
     */
    fun `depthBiasSlopeScale$layout`(): ValueLayout.OfFloat {
        return `depthBiasSlopeScale$LAYOUT`
    }

    private const val `depthBiasSlopeScale$OFFSET`: Long = 64

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * float depthBiasSlopeScale
     * * }
     */
    fun `depthBiasSlopeScale$offset`(): Long {
        return `depthBiasSlopeScale$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * float depthBiasSlopeScale
     * * }
     */
    fun depthBiasSlopeScale(struct: MemorySegment): Float {
        return struct.get(`depthBiasSlopeScale$LAYOUT`, `depthBiasSlopeScale$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * float depthBiasSlopeScale
     * * }
     */
    fun depthBiasSlopeScale(struct: MemorySegment, fieldValue: Float) {
        struct.set(`depthBiasSlopeScale$LAYOUT`, `depthBiasSlopeScale$OFFSET`, fieldValue)
    }

    private val `depthBiasClamp$LAYOUT` = `$LAYOUT`.select(groupElement("depthBiasClamp")) as ValueLayout.OfFloat

    /**
     * Layout for field:
     * {@snippet lang=c :
     * * float depthBiasClamp
     * * }
     */
    fun `depthBiasClamp$layout`(): ValueLayout.OfFloat {
        return `depthBiasClamp$LAYOUT`
    }

    private const val `depthBiasClamp$OFFSET`: Long = 68

    /**
     * Offset for field:
     * {@snippet lang=c :
     * * float depthBiasClamp
     * * }
     */
    fun `depthBiasClamp$offset`(): Long {
        return `depthBiasClamp$OFFSET`
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * * float depthBiasClamp
     * * }
     */
    fun depthBiasClamp(struct: MemorySegment): Float {
        return struct.get(`depthBiasClamp$LAYOUT`, `depthBiasClamp$OFFSET`)
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * * float depthBiasClamp
     * * }
     */
    fun depthBiasClamp(struct: MemorySegment, fieldValue: Float) {
        struct.set(`depthBiasClamp$LAYOUT`, `depthBiasClamp$OFFSET`, fieldValue)
    }

    /**
     * Obtains a slice of `arrayParam` which selects the array element at `index`.
     * The returned segment has address `arrayParam.address() + index * layout().byteSize()`
     */
    fun asSlice(array: MemorySegment, index: Long): MemorySegment {
        return array.asSlice(layout().byteSize() * index)
    }

    /**
     * The size (in bytes) of this struct
     */
    fun sizeof(): Long {
        return layout().byteSize()
    }

    /**
     * Allocate a segment of size `layout().byteSize()` using `allocator`
     */
    fun allocate(allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(layout())
    }

    /**
     * Allocate an array of size `elementCount` using `allocator`.
     * The returned segment has size `elementCount * layout().byteSize()`.
     */
    fun allocateArray(elementCount: Long, allocator: SegmentAllocator): MemorySegment {
        return allocator.allocate(sequenceLayout(elementCount, layout()))
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `layout().byteSize()`
     */
    fun reinterpret(addr: MemorySegment, arena: Arena, cleanup: Consumer<MemorySegment?>): MemorySegment {
        return reinterpret(addr, 1, arena, cleanup)
    }

    /**
     * Reinterprets `addr` using target `arena` and `cleanupAction` (if any).
     * The returned segment has size `elementCount * layout().byteSize()`
     */
    fun reinterpret(
        addr: MemorySegment,
        elementCount: Long,
        arena: Arena,
        cleanup: Consumer<MemorySegment?>
    ): MemorySegment {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup)
    }
}

